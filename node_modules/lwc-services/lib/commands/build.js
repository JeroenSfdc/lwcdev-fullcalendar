"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const command_1 = require("@oclif/command");
const fs_1 = require("fs");
const path_1 = require("path");
const rimraf = require("rimraf");
const webpack_merge_1 = require("webpack-merge");
const lwcConfig_1 = require("../config/lwcConfig");
const webpack_config_1 = require("../config/webpack.config");
const build_1 = require("../messages/build");
const logger_1 = require("../utils/logger");
const statsAnalyzer_1 = require("../utils/webpack/statsAnalyzer");
const migration_1 = require("../utils/migration");
const spawn = require('child_process').spawn;
const rollupConfig = path_1.resolve(__dirname, '../config/rollup.config.js');
function buildWebpack(webpackConfig) {
    const webpack = require('webpack');
    return new Promise((resolve, reject) => {
        webpack(webpackConfig, (err, stats) => {
            if (err) {
                return reject(err);
            }
            if (!stats || !stats.compilation) {
                return reject(build_1.messages.errors.no_compilation);
            }
            // Parsing out error messages during compilation. Makes life MUCH easier.
            const { errors } = stats.compilation;
            if (errors.length) {
                let errorMessages = '';
                errors.forEach((error) => {
                    errorMessages = errorMessages
                        .concat(error.message)
                        .concat('\n');
                });
                return reject(errorMessages);
            }
            statsAnalyzer_1.analyzeStats(stats);
            return resolve(true);
        });
    });
}
class Build extends command_1.Command {
    // eslint-disable-next-line @typescript-eslint/explicit-module-boundary-types
    async run() {
        const { flags } = this.parse(Build);
        // eslint-disable-next-line no-console
        console.clear();
        logger_1.welcome();
        // For now we use SOURCE_DIR_DEFAULT, may become a dedicated input parameter at a later point in time
        const SOURCE_DIR = lwcConfig_1.lwcConfig.sourceDir;
        // Defining the destination directory
        const BUILD_DIR = lwcConfig_1.lwcConfig.buildDir;
        // Check if given source directory exists. If not we're exiting.
        if (!fs_1.existsSync(SOURCE_DIR)) {
            logger_1.log(build_1.messages.errors.no_source_dir, SOURCE_DIR);
            return;
        }
        // Clearing build directory, if the user didn't override.
        if (!flags.noclear) {
            if (fs_1.existsSync(BUILD_DIR)) {
                rimraf.sync(BUILD_DIR);
                logger_1.log(build_1.messages.logs.clear);
            }
        }
        await migration_1.migrateModuleResolution();
        if (flags.bundler === 'webpack') {
            // Check if custom webpack config is passed, and if it really exists.
            if (flags.webpack) {
                if (!fs_1.existsSync(flags.webpack)) {
                    logger_1.log(build_1.messages.errors.no_webpack);
                    return;
                }
            }
            logger_1.log(build_1.messages.logs.creating_build_configuration);
            let webpackConfigCustom;
            let webpackConfig = webpack_config_1.generateWebpackConfig(flags.mode, webpackConfigCustom);
            if (flags.webpack) {
                logger_1.log(build_1.messages.logs.custom_configuration);
                webpackConfigCustom = require(path_1.resolve(process.cwd(), flags.webpack));
                let mergeFunction;
                if (flags['webpack-plugin-overrides']) {
                    mergeFunction = webpack_merge_1.mergeWithCustomize({
                        customizeArray: webpack_merge_1.unique('plugins', flags['webpack-plugin-overrides'].split(','), (plugin) => plugin.constructor && plugin.constructor.name)
                    });
                }
                else {
                    mergeFunction = webpack_merge_1.merge;
                }
                webpackConfig = mergeFunction(webpackConfig, webpackConfigCustom);
            }
            logger_1.log(build_1.messages.logs.build_start);
            if (flags.mode && flags.mode !== lwcConfig_1.lwcConfig.mode) {
                webpackConfig.mode = flags.mode;
            }
            if (flags.destination && flags.destination !== lwcConfig_1.lwcConfig.buildDir) {
                webpackConfig.output.path = path_1.resolve(process.cwd(), flags.destination);
            }
            try {
                await buildWebpack(webpackConfig);
                logger_1.log(build_1.messages.logs.build_end);
            }
            catch (error) {
                logger_1.log({ message: error, emoji: 'sos' });
                process.exit(1);
            }
        }
        else {
            // This looks super wonky... and it may be super wonky. ;-)
            const args = [
                './node_modules/rollup/dist/bin/rollup',
                '-c',
                rollupConfig,
                '--environment',
                'NODE_ENV:' + flags.mode
            ];
            const rollupSpawn = spawn('node', args);
            rollupSpawn.on('error', (err) => {
                logger_1.log({ message: `${err}`, emoji: 'sos' });
            });
            // It's super weird that the debug message is passed via stderr. But it is what it is.
            rollupSpawn.stderr.on('data', (data) => {
                logger_1.log({ message: `${data}`, emoji: 'rainbow' });
            });
        }
    }
}
exports.default = Build;
Build.description = build_1.messages.description;
Build.examples = build_1.messages.help.examples;
Build.flags = {
    help: command_1.flags.help({ char: 'h' }),
    destination: command_1.flags.string({
        char: 'd',
        description: build_1.messages.flags.destination,
        default: lwcConfig_1.lwcConfig.buildDir
    }),
    mode: command_1.flags.string({
        char: 'm',
        description: build_1.messages.flags.mode,
        default: lwcConfig_1.lwcConfig.mode
    }),
    noclear: command_1.flags.boolean({
        char: 'n',
        description: build_1.messages.flags.noclear,
        default: lwcConfig_1.lwcConfig.noclear
    }),
    webpack: command_1.flags.string({
        char: 'w',
        description: build_1.messages.flags.webpack
    }),
    'webpack-plugin-overrides': command_1.flags.string({
        description: build_1.messages.flags['webpack-plugin-overrides']
    }),
    bundler: command_1.flags.string({
        char: 'b',
        description: build_1.messages.flags.bundler,
        default: lwcConfig_1.lwcConfig.bundler
    })
};
