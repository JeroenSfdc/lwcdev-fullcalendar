(function (global, factory) {
    typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :
    typeof define === 'function' && define.amd ? define(['exports'], factory) :
    (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.LWC = {}));
}(this, (function (exports) { 'use strict';

    /*! *****************************************************************************
    Copyright (c) Microsoft Corporation.

    Permission to use, copy, modify, and/or distribute this software for any
    purpose with or without fee is hereby granted.

    THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
    REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
    AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
    INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
    LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
    OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
    PERFORMANCE OF THIS SOFTWARE.
    ***************************************************************************** */

    /* global Reflect, Promise */
    var extendStatics = function (d, b) {
      extendStatics = Object.setPrototypeOf || {
        __proto__: []
      } instanceof Array && function (d, b) {
        d.__proto__ = b;
      } || function (d, b) {
        for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];
      };

      return extendStatics(d, b);
    };

    function __extends(d, b) {
      if (typeof b !== "function" && b !== null) throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
      extendStatics(d, b);

      function __() {
        this.constructor = d;
      }

      d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
    }
    function __spreadArray(to, from) {
      for (var i = 0, il = from.length, j = to.length; i < il; i++, j++) to[j] = from[i];

      return to;
    }

    /* proxy-compat-disable */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect$1() {
        // Don't apply polyfill when ProxyCompat is enabled.
        if ('getKey' in Proxy) {
            return false;
        }
        var proxy = new Proxy([3, 4], {});
        var res = [1, 2].concat(proxy);
        return res.length !== 4;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isConcatSpreadable = Symbol.isConcatSpreadable;
    var isArray$3 = Array.isArray;
    var _b = Array.prototype, ArraySlice$2 = _b.slice, ArrayUnshift$2 = _b.unshift, ArrayShift = _b.shift;
    function isObject$2(O) {
        return typeof O === 'object' ? O !== null : typeof O === 'function';
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-isconcatspreadable
    function isSpreadable(O) {
        if (!isObject$2(O)) {
            return false;
        }
        var spreadable = O[isConcatSpreadable];
        return spreadable !== undefined ? Boolean(spreadable) : isArray$3(O);
    } // https://www.ecma-international.org/ecma-262/6.0/#sec-array.prototype.concat
    function ArrayConcatPolyfill() {
        var _args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            _args[_i] = arguments[_i];
        }
        var O = Object(this);
        var A = [];
        var N = 0;
        var items = ArraySlice$2.call(arguments);
        ArrayUnshift$2.call(items, O);
        while (items.length) {
            var E = ArrayShift.call(items);
            if (isSpreadable(E)) {
                var k_1 = 0;
                var length = E.length;
                for (k_1; k_1 < length; k_1 += 1, N += 1) {
                    if (k_1 in E) {
                        var subElement = E[k_1];
                        A[N] = subElement;
                    }
                }
            }
            else {
                A[N] = E;
                N += 1;
            }
        }
        return A;
    }
    function apply() {
        // eslint-disable-next-line no-extend-native
        Array.prototype.concat = ArrayConcatPolyfill;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (detect$1()) {
        apply();
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant$1(value, msg) {
        if (!value) {
            throw new Error("Invariant Violation: " + msg);
        }
    }
    function isTrue$1$1(value, msg) {
        if (!value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function isFalse$1$1(value, msg) {
        if (value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function fail$1(msg) {
        throw new Error(msg);
    }
    var assert$1 = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        invariant: invariant$1,
        isTrue: isTrue$1$1,
        isFalse: isFalse$1$1,
        fail: fail$1
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var assign$2 = Object.assign, create$3 = Object.create, defineProperty$2 = Object.defineProperty, freeze$2 = Object.freeze, hasOwnProperty$3 = Object.hasOwnProperty, keys$2 = Object.keys, seal$2 = Object.seal, setPrototypeOf$2 = Object.setPrototypeOf;
    var isArray$2 = Array.isArray;
    var _c = Array.prototype, ArrayJoin$1 = _c.join, ArrayMap$2 = _c.map, forEach$1 = _c.forEach;
    var _d = String.prototype, StringReplace$1 = _d.replace, StringToLowerCase$1 = _d.toLowerCase;
    function isUndefined$4(obj) {
        return obj === undefined;
    }
    function isNull$1(obj) {
        return obj === null;
    }
    function isFalse$3(obj) {
        return obj === false;
    }
    function isFunction$2(obj) {
        return typeof obj === 'function';
    }
    function isObject$1(obj) {
        return typeof obj === 'object';
    }
    var OtS$2 = {}.toString;
    function toString$2(obj) {
        if (obj && obj.toString) {
            // Arrays might hold objects with "null" prototype So using
            // Array.prototype.toString directly will cause an error Iterate through
            // all the items and handle individually.
            if (isArray$2(obj)) {
                return ArrayJoin$1.call(ArrayMap$2.call(obj, toString$2), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS$2.call(obj);
        }
        else {
            return obj + '';
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     */
    var AriaPropertyNames$1 = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var _e = (function () {
        var AriaAttrNameToPropNameMap = create$3(null);
        var AriaPropNameToAttrNameMap = create$3(null); // Synthetic creation of all AOM property descriptors for Custom Elements
        forEach$1.call(AriaPropertyNames$1, function (propName) {
            var attrName = StringToLowerCase$1.call(StringReplace$1.call(propName, /^aria/, function () { return 'aria-'; }));
            AriaAttrNameToPropNameMap[attrName] = propName;
            AriaPropNameToAttrNameMap[propName] = attrName;
        });
        return {
            AriaAttrNameToPropNameMap: AriaAttrNameToPropNameMap,
            AriaPropNameToAttrNameMap: AriaPropNameToAttrNameMap
        };
    })(), AriaPropNameToAttrNameMap$1 = _e.AriaPropNameToAttrNameMap;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // We use this to detect symbol support in order to avoid the expensive symbol polyfill. Note that
    // we can't use typeof since it will fail when transpiling.
    var hasNativeSymbolSupport$1 = /*@__PURE__*/ (function () { return Symbol('x').toString() === 'Symbol(x)'; })();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // This method abstracts the creation of symbols, so we can fallback to strings when native symbols
    // are not supported.
    function createHiddenField$1(key, namespace) {
        return hasNativeSymbolSupport$1 ? Symbol(key) : "$$lwc-" + namespace + "-" + key + "$$";
    }
    var hiddenFieldsMap$1 = new WeakMap();
    function setHiddenField$1(o, field, value) {
        var valuesByField = hiddenFieldsMap$1.get(o);
        if (isUndefined$4(valuesByField)) {
            valuesByField = create$3(null);
            hiddenFieldsMap$1.set(o, valuesByField);
        }
        valuesByField[field] = value;
    }
    function getHiddenField$1(o, field) {
        var valuesByField = hiddenFieldsMap$1.get(o);
        if (!isUndefined$4(valuesByField)) {
            return valuesByField[field];
        }
    }
    /** version: 2.1.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function detect(propName) {
        return Object.getOwnPropertyDescriptor(Element.prototype, propName) === undefined;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nodeToAriaPropertyValuesMap = new WeakMap();
    function getAriaPropertyMap(elm) {
        var map = nodeToAriaPropertyValuesMap.get(elm);
        if (map === undefined) {
            map = {};
            nodeToAriaPropertyValuesMap.set(elm, map);
        }
        return map;
    }
    function getNormalizedAriaPropertyValue(value) {
        return value == null ? null : String(value);
    }
    function createAriaPropertyPropertyDescriptor(propName, attrName) {
        return {
            get: function () {
                var map = getAriaPropertyMap(this);
                if (hasOwnProperty$3.call(map, propName)) {
                    return map[propName];
                } // otherwise just reflect what's in the attribute
                return this.hasAttribute(attrName) ? this.getAttribute(attrName) : null;
            },
            set: function (newValue) {
                var normalizedValue = getNormalizedAriaPropertyValue(newValue);
                var map = getAriaPropertyMap(this);
                map[propName] = normalizedValue; // reflect into the corresponding attribute
                if (newValue === null) {
                    this.removeAttribute(attrName);
                }
                else {
                    this.setAttribute(attrName, newValue);
                }
            },
            configurable: true,
            enumerable: true
        };
    }
    function patch(propName) {
        // Typescript is inferring the wrong function type for this particular
        // overloaded method: https://github.com/Microsoft/TypeScript/issues/27972
        // @ts-ignore type-mismatch
        var attrName = AriaPropNameToAttrNameMap$1[propName];
        var descriptor = createAriaPropertyPropertyDescriptor(propName, attrName);
        Object.defineProperty(Element.prototype, propName, descriptor);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ElementPrototypeAriaPropertyNames = keys$2(AriaPropNameToAttrNameMap$1);
    for (var i_2 = 0, len = ElementPrototypeAriaPropertyNames.length; i_2 < len; i_2 += 1) {
        var propName = ElementPrototypeAriaPropertyNames[i_2];
        if (detect(propName)) {
            patch(propName);
        }
    }
    /* proxy-compat-disable */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function invariant(value, msg) {
        if (!value) {
            throw new Error("Invariant Violation: " + msg);
        }
    }
    function isTrue$1(value, msg) {
        if (!value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function isFalse$1(value, msg) {
        if (value) {
            throw new Error("Assert Violation: " + msg);
        }
    }
    function fail(msg) {
        throw new Error(msg);
    }
    var assert = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        invariant: invariant,
        isTrue: isTrue$1,
        isFalse: isFalse$1,
        fail: fail
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var assign$1 = Object.assign, create$2 = Object.create, defineProperties$1 = Object.defineProperties, defineProperty$1 = Object.defineProperty, freeze$1 = Object.freeze, getOwnPropertyDescriptor$2 = Object.getOwnPropertyDescriptor, getOwnPropertyNames$2 = Object.getOwnPropertyNames, getPrototypeOf$2 = Object.getPrototypeOf, hasOwnProperty$2 = Object.hasOwnProperty, isFrozen$1 = Object.isFrozen, keys$1 = Object.keys, seal$1 = Object.seal, setPrototypeOf$1 = Object.setPrototypeOf;
    var isArray$1 = Array.isArray;
    var _f = Array.prototype, ArrayJoin = _f.join, ArrayMap$1 = _f.map, ArrayPush$2 = _f.push, ArraySlice = _f.slice, ArrayUnshift = _f.unshift, forEach = _f.forEach;
    var StringFromCharCode = String.fromCharCode;
    var _g = String.prototype, StringCharCodeAt = _g.charCodeAt, StringReplace = _g.replace, StringSlice = _g.slice, StringToLowerCase = _g.toLowerCase;
    function isUndefined$3(obj) {
        return obj === undefined;
    }
    function isNull(obj) {
        return obj === null;
    }
    function isTrue$2(obj) {
        return obj === true;
    }
    function isFalse$2(obj) {
        return obj === false;
    }
    function isFunction$1(obj) {
        return typeof obj === 'function';
    }
    function isString(obj) {
        return typeof obj === 'string';
    }
    var OtS$1 = {}.toString;
    function toString$1(obj) {
        if (obj && obj.toString) {
            // Arrays might hold objects with "null" prototype So using
            // Array.prototype.toString directly will cause an error Iterate through
            // all the items and handle individually.
            if (isArray$1(obj)) {
                return ArrayJoin.call(ArrayMap$1.call(obj, toString$1), ',');
            }
            return obj.toString();
        }
        else if (typeof obj === 'object') {
            return OtS$1.call(obj);
        }
        else {
            return obj + '';
        }
    }
    function getPropertyDescriptor(o, p) {
        do {
            var d_1 = getOwnPropertyDescriptor$2(o, p);
            if (!isUndefined$3(d_1)) {
                return d_1;
            }
            o = getPrototypeOf$2(o);
        } while (o !== null);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * According to the following list, there are 48 aria attributes of which two (ariaDropEffect and
     * ariaGrabbed) are deprecated:
     * https://www.w3.org/TR/wai-aria-1.1/#x6-6-definitions-of-states-and-properties-all-aria-attributes
     *
     * The above list of 46 aria attributes is consistent with the following resources:
     * https://github.com/w3c/aria/pull/708/files#diff-eacf331f0ffc35d4b482f1d15a887d3bR11060
     * https://wicg.github.io/aom/spec/aria-reflection.html
     */
    var AriaPropertyNames = ['ariaActiveDescendant', 'ariaAtomic', 'ariaAutoComplete', 'ariaBusy', 'ariaChecked', 'ariaColCount', 'ariaColIndex', 'ariaColSpan', 'ariaControls', 'ariaCurrent', 'ariaDescribedBy', 'ariaDetails', 'ariaDisabled', 'ariaErrorMessage', 'ariaExpanded', 'ariaFlowTo', 'ariaHasPopup', 'ariaHidden', 'ariaInvalid', 'ariaKeyShortcuts', 'ariaLabel', 'ariaLabelledBy', 'ariaLevel', 'ariaLive', 'ariaModal', 'ariaMultiLine', 'ariaMultiSelectable', 'ariaOrientation', 'ariaOwns', 'ariaPlaceholder', 'ariaPosInSet', 'ariaPressed', 'ariaReadOnly', 'ariaRelevant', 'ariaRequired', 'ariaRoleDescription', 'ariaRowCount', 'ariaRowIndex', 'ariaRowSpan', 'ariaSelected', 'ariaSetSize', 'ariaSort', 'ariaValueMax', 'ariaValueMin', 'ariaValueNow', 'ariaValueText', 'role'];
    var _h = (function () {
        var AriaAttrNameToPropNameMap = create$2(null);
        var AriaPropNameToAttrNameMap = create$2(null); // Synthetic creation of all AOM property descriptors for Custom Elements
        forEach.call(AriaPropertyNames, function (propName) {
            var attrName = StringToLowerCase.call(StringReplace.call(propName, /^aria/, function () { return 'aria-'; }));
            AriaAttrNameToPropNameMap[attrName] = propName;
            AriaPropNameToAttrNameMap[propName] = attrName;
        });
        return {
            AriaAttrNameToPropNameMap: AriaAttrNameToPropNameMap,
            AriaPropNameToAttrNameMap: AriaPropNameToAttrNameMap
        };
    })(), AriaPropNameToAttrNameMap = _h.AriaPropNameToAttrNameMap;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // We use this to detect symbol support in order to avoid the expensive symbol polyfill. Note that
    // we can't use typeof since it will fail when transpiling.
    var hasNativeSymbolSupport = /*@__PURE__*/ (function () { return Symbol('x').toString() === 'Symbol(x)'; })();
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // This method abstracts the creation of symbols, so we can fallback to strings when native symbols
    // are not supported.
    function createHiddenField(key, namespace) {
        return hasNativeSymbolSupport ? Symbol(key) : "$$lwc-" + namespace + "-" + key + "$$";
    }
    var hiddenFieldsMap = new WeakMap();
    function setHiddenField(o, field, value) {
        var valuesByField = hiddenFieldsMap.get(o);
        if (isUndefined$3(valuesByField)) {
            valuesByField = create$2(null);
            hiddenFieldsMap.set(o, valuesByField);
        }
        valuesByField[field] = value;
    }
    function getHiddenField(o, field) {
        var valuesByField = hiddenFieldsMap.get(o);
        if (!isUndefined$3(valuesByField)) {
            return valuesByField[field];
        }
    }
    /**
     * Map composed of properties to attributes not following the HTML property to attribute mapping
     * convention.
     */
    var NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING = new Map([['accessKey', 'accesskey'], ['readOnly', 'readonly'], ['tabIndex', 'tabindex'], ['bgColor', 'bgcolor'], ['colSpan', 'colspan'], ['rowSpan', 'rowspan'], ['contentEditable', 'contenteditable'], ['crossOrigin', 'crossorigin'], ['dateTime', 'datetime'], ['formAction', 'formaction'], ['isMap', 'ismap'], ['maxLength', 'maxlength'], ['minLength', 'minlength'], ['noValidate', 'novalidate'], ['useMap', 'usemap'], ['htmlFor', 'for']]);
    /**
     * Map associating previously transformed HTML property into HTML attribute.
     */
    var CACHED_PROPERTY_ATTRIBUTE_MAPPING = new Map();
    function htmlPropertyToAttribute(propName) {
        var ariaAttributeName = AriaPropNameToAttrNameMap[propName];
        if (!isUndefined$3(ariaAttributeName)) {
            return ariaAttributeName;
        }
        var specialAttributeName = NO_STANDARD_PROPERTY_ATTRIBUTE_MAPPING.get(propName);
        if (!isUndefined$3(specialAttributeName)) {
            return specialAttributeName;
        }
        var cachedAttributeName = CACHED_PROPERTY_ATTRIBUTE_MAPPING.get(propName);
        if (!isUndefined$3(cachedAttributeName)) {
            return cachedAttributeName;
        }
        var attributeName = '';
        for (var i_3 = 0, len = propName.length; i_3 < len; i_3++) {
            var code = StringCharCodeAt.call(propName, i_3);
            if (code >= 65 && // "A"
                code <= 90 // "Z"
            ) {
                attributeName += '-' + StringFromCharCode(code + 32);
            }
            else {
                attributeName += StringFromCharCode(code);
            }
        }
        CACHED_PROPERTY_ATTRIBUTE_MAPPING.set(propName, attributeName);
        return attributeName;
    }
    /** version: 2.1.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var nextTickCallbackQueue = [];
    var SPACE_CHAR = 32;
    var EmptyObject = seal$1(create$2(null));
    var EmptyArray = seal$1([]);
    function flushCallbackQueue() {
        var callbacks = nextTickCallbackQueue;
        nextTickCallbackQueue = []; // reset to a new queue
        for (var i_4 = 0, len = callbacks.length; i_4 < len; i_4 += 1) {
            callbacks[i_4]();
        }
    }
    function addCallbackToNextTick(callback) {
        if (nextTickCallbackQueue.length === 0) {
            Promise.resolve().then(flushCallbackQueue);
        }
        ArrayPush$2.call(nextTickCallbackQueue, callback);
    }
    function guid() {
        function s4() {
            return Math.floor((1 + Math.random()) * 0x10000).toString(16).substring(1);
        }
        return s4() + s4() + '-' + s4() + '-' + s4() + '-' + s4() + '-' + s4() + s4() + s4();
    }
    /*
     * Copyright (c) 2019, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create$1 = Object.create;
    var _j = Array.prototype, ArraySplice = _j.splice, ArrayIndexOf = _j.indexOf, ArrayPush$1 = _j.push;
    var TargetToReactiveRecordMap = new WeakMap();
    function isUndefined$2(obj) {
        return obj === undefined;
    }
    function getReactiveRecord(target) {
        var reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (isUndefined$2(reactiveRecord)) {
            var newRecord = create$1(null);
            reactiveRecord = newRecord;
            TargetToReactiveRecordMap.set(target, newRecord);
        }
        return reactiveRecord;
    }
    var currentReactiveObserver = null;
    function valueMutated(target, key) {
        var reactiveRecord = TargetToReactiveRecordMap.get(target);
        if (!isUndefined$2(reactiveRecord)) {
            var reactiveObservers = reactiveRecord[key];
            if (!isUndefined$2(reactiveObservers)) {
                for (var i_5 = 0, len = reactiveObservers.length; i_5 < len; i_5 += 1) {
                    var ro = reactiveObservers[i_5];
                    ro.notify();
                }
            }
        }
    }
    function valueObserved(target, key) {
        // We should determine if an active Observing Record is present to track mutations.
        if (currentReactiveObserver === null) {
            return;
        }
        var ro = currentReactiveObserver;
        var reactiveRecord = getReactiveRecord(target);
        var reactiveObservers = reactiveRecord[key];
        if (isUndefined$2(reactiveObservers)) {
            reactiveObservers = [];
            reactiveRecord[key] = reactiveObservers;
        }
        else if (reactiveObservers[0] === ro) {
            return; // perf optimization considering that most subscriptions will come from the same record
        }
        if (ArrayIndexOf.call(reactiveObservers, ro) === -1) {
            ro.link(reactiveObservers);
        }
    }
    var ReactiveObserver = /** @class */ (function () {
        function ReactiveObserver(callback) {
            this.listeners = [];
            this.callback = callback;
        }
        ReactiveObserver.prototype.observe = function (job) {
            var inceptionReactiveRecord = currentReactiveObserver;
            currentReactiveObserver = this;
            var error;
            try {
                job();
            }
            catch (e) {
                error = Object(e);
            }
            finally {
                currentReactiveObserver = inceptionReactiveRecord;
                if (error !== undefined) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
            }
        };
        /**
         * This method is responsible for disconnecting the Reactive Observer
         * from any Reactive Record that has a reference to it, to prevent future
         * notifications about previously recorded access.
         */
        ReactiveObserver.prototype.reset = function () {
            var listeners = this.listeners;
            var len = listeners.length;
            if (len > 0) {
                for (var i_6 = 0; i_6 < len; i_6 += 1) {
                    var set = listeners[i_6];
                    var pos = ArrayIndexOf.call(listeners[i_6], this);
                    ArraySplice.call(set, pos, 1);
                }
                listeners.length = 0;
            }
        }; // friend methods
        ReactiveObserver.prototype.notify = function () {
            this.callback.call(undefined, this);
        };
        ReactiveObserver.prototype.link = function (reactiveObservers) {
            ArrayPush$1.call(reactiveObservers, this); // we keep track of observing records where the observing record was added to so we can do some clean up later on
            ArrayPush$1.call(this.listeners, reactiveObservers);
        };
        return ReactiveObserver;
    }());
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function componentValueMutated(vm, key) {
        valueMutated(vm.component, key);
    }
    function componentValueObserved(vm, key) {
        valueObserved(vm.component, key);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getComponentTag(vm) {
        return "<" + StringToLowerCase.call(vm.tagName) + ">";
    } // TODO [#1695]: Unify getComponentStack and getErrorComponentStack
    function getErrorComponentStack(vm) {
        var wcStack = [];
        var currentVm = vm;
        while (!isNull(currentVm)) {
            ArrayPush$2.call(wcStack, getComponentTag(currentVm));
            currentVm = currentVm.owner;
        }
        return wcStack.reverse().join('\n\t');
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function handleEvent(event, vnode) {
        var type = event.type;
        var on = vnode.data.on;
        var handler = on && on[type]; // call event handler if exists
        if (handler) {
            handler.call(undefined, event);
        }
    }
    function createListener() {
        return function handler(event) {
            handleEvent(event, handler.vnode);
        };
    }
    function updateAllEventListeners(oldVnode, vnode) {
        if (isUndefined$3(oldVnode.listener)) {
            createAllEventListeners(vnode);
        }
        else {
            vnode.listener = oldVnode.listener;
            vnode.listener.vnode = vnode;
        }
    }
    function createAllEventListeners(vnode) {
        var elm = vnode.elm, on = vnode.data.on, renderer = vnode.owner.renderer;
        if (isUndefined$3(on)) {
            return;
        }
        var listener = vnode.listener = createListener();
        listener.vnode = vnode;
        var name;
        for (name in on) {
            renderer.addEventListener(elm, name, listener);
        }
    }
    var modEvents = {
        update: updateAllEventListeners,
        create: createAllEventListeners
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var defaultDefHTMLPropertyNames = ['accessKey', 'dir', 'draggable', 'hidden', 'id', 'lang', 'spellcheck', 'tabIndex', 'title'];
    function offsetPropertyErrorMessage(name) {
        return "Using the `" + name + "` property is an anti-pattern because it rounds the value to an integer. Instead, use the `getBoundingClientRect` method to obtain fractional values for the size of an element and its position relative to the viewport.";
    } // Global HTML Attributes & Properties
    // https://developer.mozilla.org/en-US/docs/Web/HTML/Global_attributes
    // https://developer.mozilla.org/en-US/docs/Web/API/HTMLElement
    assign$1(create$2(null), {
        accessKey: {
            attribute: 'accesskey'
        },
        accessKeyLabel: {
            readOnly: true
        },
        className: {
            attribute: 'class',
            error: 'Using the `className` property is an anti-pattern because of slow runtime behavior and potential conflicts with classes provided by the owner element. Use the `classList` API instead.'
        },
        contentEditable: {
            attribute: 'contenteditable'
        },
        dataset: {
            readOnly: true,
            error: "Using the `dataset` property is an anti-pattern because it can't be statically analyzed. Expose each property individually using the `@api` decorator instead."
        },
        dir: {
            attribute: 'dir'
        },
        draggable: {
            attribute: 'draggable'
        },
        dropzone: {
            attribute: 'dropzone',
            readOnly: true
        },
        hidden: {
            attribute: 'hidden'
        },
        id: {
            attribute: 'id'
        },
        inputMode: {
            attribute: 'inputmode'
        },
        lang: {
            attribute: 'lang'
        },
        slot: {
            attribute: 'slot',
            error: 'Using the `slot` property is an anti-pattern.'
        },
        spellcheck: {
            attribute: 'spellcheck'
        },
        style: {
            attribute: 'style'
        },
        tabIndex: {
            attribute: 'tabindex'
        },
        title: {
            attribute: 'title'
        },
        translate: {
            attribute: 'translate'
        },
        // additional "global attributes" that are not present in the link above.
        isContentEditable: {
            readOnly: true
        },
        offsetHeight: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetHeight')
        },
        offsetLeft: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetLeft')
        },
        offsetParent: {
            readOnly: true
        },
        offsetTop: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetTop')
        },
        offsetWidth: {
            readOnly: true,
            error: offsetPropertyErrorMessage('offsetWidth')
        },
        role: {
            attribute: 'role'
        }
    });
    var controlledElement = null;
    var controlledAttributeName;
    function isAttributeLocked(elm, attrName) {
        return elm !== controlledElement || attrName !== controlledAttributeName;
    }
    function lockAttribute(_elm, _key) {
        controlledElement = null;
        controlledAttributeName = undefined;
    }
    function unlockAttribute(elm, key) {
        controlledElement = elm;
        controlledAttributeName = key;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var xlinkNS = 'http://www.w3.org/1999/xlink';
    var xmlNS = 'http://www.w3.org/XML/1998/namespace';
    var ColonCharCode = 58;
    function updateAttrs(oldVnode, vnode) {
        var attrs = vnode.data.attrs, renderer = vnode.owner.renderer;
        if (isUndefined$3(attrs)) {
            return;
        }
        var oldAttrs = oldVnode.data.attrs;
        if (oldAttrs === attrs) {
            return;
        }
        var elm = vnode.elm;
        var setAttribute = renderer.setAttribute, removeAttribute = renderer.removeAttribute;
        var key;
        oldAttrs = isUndefined$3(oldAttrs) ? EmptyObject : oldAttrs; // update modified attributes, add new attributes
        // this routine is only useful for data-* attributes in all kind of elements
        // and aria-* in standard elements (custom elements will use props for these)
        for (key in attrs) {
            var cur = attrs[key];
            var old = oldAttrs[key];
            if (old !== cur) {
                unlockAttribute(elm, key);
                if (StringCharCodeAt.call(key, 3) === ColonCharCode) {
                    // Assume xml namespace
                    setAttribute(elm, key, cur, xmlNS);
                }
                else if (StringCharCodeAt.call(key, 5) === ColonCharCode) {
                    // Assume xlink namespace
                    setAttribute(elm, key, cur, xlinkNS);
                }
                else if (isNull(cur)) {
                    removeAttribute(elm, key);
                }
                else {
                    setAttribute(elm, key, cur);
                }
                lockAttribute();
            }
        }
    }
    var emptyVNode$3 = {
        data: {}
    };
    var modAttrs = {
        create: function (vnode) { return updateAttrs(emptyVNode$3, vnode); },
        update: updateAttrs
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function isLiveBindingProp(sel, key) {
        // For properties with live bindings, we read values from the DOM element
        // instead of relying on internally tracked values.
        return sel === 'input' && (key === 'value' || key === 'checked');
    }
    function update(oldVnode, vnode) {
        var props = vnode.data.props;
        if (isUndefined$3(props)) {
            return;
        }
        var oldProps = oldVnode.data.props;
        if (oldProps === props) {
            return;
        }
        var isFirstPatch = isUndefined$3(oldProps);
        var elm = vnode.elm, sel = vnode.sel, renderer = vnode.owner.renderer;
        for (var key in props) {
            var cur = props[key]; // if it is the first time this element is patched, or the current value is different to the previous value...
            if (isFirstPatch || cur !== (isLiveBindingProp(sel, key) ? renderer.getProperty(elm, key) : oldProps[key])) {
                renderer.setProperty(elm, key, cur);
            }
        }
    }
    var emptyVNode$2 = {
        data: {}
    };
    var modProps = {
        create: function (vnode) { return update(emptyVNode$2, vnode); },
        update: update
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var classNameToClassMap = create$2(null);
    function getMapFromClassName(className) {
        // Intentionally using == to match undefined and null values from computed style attribute
        if (className == null) {
            return EmptyObject;
        } // computed class names must be string
        className = isString(className) ? className : className + '';
        var map = classNameToClassMap[className];
        if (map) {
            return map;
        }
        map = create$2(null);
        var start = 0;
        var o;
        var len = className.length;
        for (o = 0; o < len; o++) {
            if (StringCharCodeAt.call(className, o) === SPACE_CHAR) {
                if (o > start) {
                    map[StringSlice.call(className, start, o)] = true;
                }
                start = o + 1;
            }
        }
        if (o > start) {
            map[StringSlice.call(className, start, o)] = true;
        }
        classNameToClassMap[className] = map;
        return map;
    }
    function updateClassAttribute(oldVnode, vnode) {
        var elm = vnode.elm, newClass = vnode.data.className, renderer = vnode.owner.renderer;
        var oldClass = oldVnode.data.className;
        if (oldClass === newClass) {
            return;
        }
        var classList = renderer.getClassList(elm);
        var newClassMap = getMapFromClassName(newClass);
        var oldClassMap = getMapFromClassName(oldClass);
        var name;
        for (name in oldClassMap) {
            // remove only if it is not in the new class collection and it is not set from within the instance
            if (isUndefined$3(newClassMap[name])) {
                classList.remove(name);
            }
        }
        for (name in newClassMap) {
            if (isUndefined$3(oldClassMap[name])) {
                classList.add(name);
            }
        }
    }
    var emptyVNode$1 = {
        data: {}
    };
    var modComputedClassName = {
        create: function (vnode) { return updateClassAttribute(emptyVNode$1, vnode); },
        update: updateClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function updateStyleAttribute(oldVnode, vnode) {
        var elm = vnode.elm, newStyle = vnode.data.style, renderer = vnode.owner.renderer;
        var setAttribute = renderer.setAttribute, removeAttribute = renderer.removeAttribute;
        if (oldVnode.data.style === newStyle) {
            return;
        }
        if (!isString(newStyle) || newStyle === '') {
            removeAttribute(elm, 'style');
        }
        else {
            setAttribute(elm, 'style', newStyle);
        }
    }
    var emptyVNode = {
        data: {}
    };
    var modComputedStyle = {
        create: function (vnode) { return updateStyleAttribute(emptyVNode, vnode); },
        update: updateStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline classnames into an object. It's faster to set the
    // different classnames properties individually instead of via a string.
    function createClassAttribute(vnode) {
        var elm = vnode.elm, classMap = vnode.data.classMap, renderer = vnode.owner.renderer;
        if (isUndefined$3(classMap)) {
            return;
        }
        var classList = renderer.getClassList(elm);
        for (var name in classMap) {
            classList.add(name);
        }
    }
    var modStaticClassName = {
        create: createClassAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // The compiler takes care of transforming the inline style into an object. It's faster to set the
    // different style properties individually instead of via a string.
    function createStyleAttribute(vnode) {
        var elm = vnode.elm, styleMap = vnode.data.styleMap, renderer = vnode.owner.renderer;
        if (isUndefined$3(styleMap)) {
            return;
        }
        for (var name in styleMap) {
            renderer.setCSSStyleProperty(elm, name, styleMap[name]);
        }
    }
    var modStaticStyle = {
        create: createStyleAttribute
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
    @license
    Copyright (c) 2015 Simon Friis Vindum.
    This code may only be used under the MIT License found at
    https://github.com/snabbdom/snabbdom/blob/master/LICENSE
    Code distributed by Snabbdom as part of the Snabbdom project at
    https://github.com/snabbdom/snabbdom/
    */
    function isUndef(s) {
        return s === undefined;
    }
    function sameVnode(vnode1, vnode2) {
        return vnode1.key === vnode2.key && vnode1.sel === vnode2.sel;
    }
    function isVNode(vnode) {
        return vnode != null;
    }
    function createKeyToOldIdx(children, beginIdx, endIdx) {
        var map = {};
        var j, key, ch; // TODO [#1637]: simplify this by assuming that all vnodes has keys
        for (j = beginIdx; j <= endIdx; ++j) {
            ch = children[j];
            if (isVNode(ch)) {
                key = ch.key;
                if (key !== undefined) {
                    map[key] = j;
                }
            }
        }
        return map;
    }
    function addVnodes(parentElm, before, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx];
            if (isVNode(ch)) {
                ch.hook.create(ch);
                ch.hook.insert(ch, parentElm, before);
            }
        }
    }
    function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
        for (; startIdx <= endIdx; ++startIdx) {
            var ch = vnodes[startIdx]; // text nodes do not have logic associated to them
            if (isVNode(ch)) {
                ch.hook.remove(ch, parentElm);
            }
        }
    }
    function updateDynamicChildren(parentElm, oldCh, newCh) {
        var oldStartIdx = 0;
        var newStartIdx = 0;
        var oldEndIdx = oldCh.length - 1;
        var oldStartVnode = oldCh[0];
        var oldEndVnode = oldCh[oldEndIdx];
        var newChEnd = newCh.length - 1;
        var newEndIdx = newChEnd;
        var newStartVnode = newCh[0];
        var newEndVnode = newCh[newEndIdx];
        var oldKeyToIdx;
        var idxInOld;
        var elmToMove;
        var before;
        while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
            if (!isVNode(oldStartVnode)) {
                oldStartVnode = oldCh[++oldStartIdx]; // Vnode might have been moved left
            }
            else if (!isVNode(oldEndVnode)) {
                oldEndVnode = oldCh[--oldEndIdx];
            }
            else if (!isVNode(newStartVnode)) {
                newStartVnode = newCh[++newStartIdx];
            }
            else if (!isVNode(newEndVnode)) {
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newStartVnode)) {
                patchVnode(oldStartVnode, newStartVnode);
                oldStartVnode = oldCh[++oldStartIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else if (sameVnode(oldEndVnode, newEndVnode)) {
                patchVnode(oldEndVnode, newEndVnode);
                oldEndVnode = oldCh[--oldEndIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldStartVnode, newEndVnode)) {
                // Vnode moved right
                patchVnode(oldStartVnode, newEndVnode);
                newEndVnode.hook.move(oldStartVnode, parentElm, oldEndVnode.owner.renderer.nextSibling(oldEndVnode.elm));
                oldStartVnode = oldCh[++oldStartIdx];
                newEndVnode = newCh[--newEndIdx];
            }
            else if (sameVnode(oldEndVnode, newStartVnode)) {
                // Vnode moved left
                patchVnode(oldEndVnode, newStartVnode);
                newStartVnode.hook.move(oldEndVnode, parentElm, oldStartVnode.elm);
                oldEndVnode = oldCh[--oldEndIdx];
                newStartVnode = newCh[++newStartIdx];
            }
            else {
                if (oldKeyToIdx === undefined) {
                    oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
                }
                idxInOld = oldKeyToIdx[newStartVnode.key];
                if (isUndef(idxInOld)) {
                    // New element
                    newStartVnode.hook.create(newStartVnode);
                    newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                    newStartVnode = newCh[++newStartIdx];
                }
                else {
                    elmToMove = oldCh[idxInOld];
                    if (isVNode(elmToMove)) {
                        if (elmToMove.sel !== newStartVnode.sel) {
                            // New element
                            newStartVnode.hook.create(newStartVnode);
                            newStartVnode.hook.insert(newStartVnode, parentElm, oldStartVnode.elm);
                        }
                        else {
                            patchVnode(elmToMove, newStartVnode);
                            oldCh[idxInOld] = undefined;
                            newStartVnode.hook.move(elmToMove, parentElm, oldStartVnode.elm);
                        }
                    }
                    newStartVnode = newCh[++newStartIdx];
                }
            }
        }
        if (oldStartIdx <= oldEndIdx || newStartIdx <= newEndIdx) {
            if (oldStartIdx > oldEndIdx) {
                // There's some cases in which the sub array of vnodes to be inserted is followed by null(s) and an
                // already processed vnode, in such cases the vnodes to be inserted should be before that processed vnode.
                var i_7 = newEndIdx;
                var n = void 0;
                do {
                    n = newCh[++i_7];
                } while (!isVNode(n) && i_7 < newChEnd);
                before = isVNode(n) ? n.elm : null;
                addVnodes(parentElm, before, newCh, newStartIdx, newEndIdx);
            }
            else {
                removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
            }
        }
    }
    function updateStaticChildren(parentElm, oldCh, newCh) {
        var oldChLength = oldCh.length;
        var newChLength = newCh.length;
        if (oldChLength === 0) {
            // the old list is empty, we can directly insert anything new
            addVnodes(parentElm, null, newCh, 0, newChLength);
            return;
        }
        if (newChLength === 0) {
            // the old list is nonempty and the new list is empty so we can directly remove all old nodes
            // this is the case in which the dynamic children of an if-directive should be removed
            removeVnodes(parentElm, oldCh, 0, oldChLength);
            return;
        } // if the old list is not empty, the new list MUST have the same
        // amount of nodes, that's why we call this static children
        var referenceElm = null;
        for (var i_8 = newChLength - 1; i_8 >= 0; i_8 -= 1) {
            var vnode = newCh[i_8];
            var oldVNode = oldCh[i_8];
            if (vnode !== oldVNode) {
                if (isVNode(oldVNode)) {
                    if (isVNode(vnode)) {
                        // both vnodes must be equivalent, and se just need to patch them
                        patchVnode(oldVNode, vnode);
                        referenceElm = vnode.elm;
                    }
                    else {
                        // removing the old vnode since the new one is null
                        oldVNode.hook.remove(oldVNode, parentElm);
                    }
                }
                else if (isVNode(vnode)) {
                    // this condition is unnecessary
                    vnode.hook.create(vnode); // insert the new node one since the old one is null
                    vnode.hook.insert(vnode, parentElm, referenceElm);
                    referenceElm = vnode.elm;
                }
            }
        }
    }
    function patchVnode(oldVnode, vnode) {
        if (oldVnode !== vnode) {
            vnode.elm = oldVnode.elm;
            vnode.hook.update(oldVnode, vnode);
        }
    }
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /**
     * Copyright (C) 2018 salesforce.com, inc.
     */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var create = Object.create;
    function isUndefined$1(obj) {
        return obj === undefined;
    }
    function isTrue(obj) {
        return obj === true;
    }
    function isFalse(obj) {
        return obj === false;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // Inspired from: https://mathiasbynens.be/notes/globalthis
    var _globalThis = /*@__PURE__*/ function () {
        // On recent browsers, `globalThis` is already defined. In this case return it directly.
        if (typeof globalThis === 'object') {
            return globalThis;
        }
        var _globalThis;
        try {
            // eslint-disable-next-line no-extend-native
            Object.defineProperty(Object.prototype, '__magic__', {
                get: function () {
                    return this;
                },
                configurable: true
            }); // __magic__ is undefined in Safari 10 and IE10 and older.
            // @ts-ignore
            // eslint-disable-next-line no-undef
            _globalThis = __magic__; // @ts-ignore
            delete Object.prototype.__magic__;
        }
        catch (ex) { // In IE8, Object.defineProperty only works on DOM objects.
        }
        finally {
            // If the magic above fails for some reason we assume that we are in a legacy browser.
            // Assume `window` exists in this case.
            if (typeof _globalThis === 'undefined') {
                // @ts-ignore
                _globalThis = window;
            }
        }
        return _globalThis;
    }();
    /** version: 2.1.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    if (!_globalThis.lwcRuntimeFlags) {
        Object.defineProperty(_globalThis, 'lwcRuntimeFlags', {
            value: create(null)
        });
    }
    var runtimeFlags = _globalThis.lwcRuntimeFlags; // This function is not supported for use within components and is meant for
    // configuring runtime feature flags during app initialization.
    function setFeatureFlag(name, value) {
        var isBoolean = isTrue(value) || isFalse(value);
        if (!isBoolean) {
            var message = "Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\". Runtime feature flags can only be set to a boolean value.";
            {
                // eslint-disable-next-line no-console
                console.error(message);
                return;
            }
        }
        if (isUndefined$1(featureFlagLookup[name])) {
            // eslint-disable-next-line no-console
            console.warn("Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\" because it is undefined. Possible reasons are that 1) it was misspelled or 2) it was removed from the @lwc/features package.");
            return;
        }
        {
            // Disallow the same flag to be set more than once in production
            var runtimeValue = runtimeFlags[name];
            if (!isUndefined$1(runtimeValue)) {
                // eslint-disable-next-line no-console
                console.error("Failed to set the value \"" + value + "\" for the runtime feature flag \"" + name + "\". \"" + name + "\" has already been set with the value \"" + runtimeValue + "\".");
                return;
            }
            Object.defineProperty(runtimeFlags, name, {
                value: value
            });
        }
    } // This function is exposed to components to facilitate testing so we add a
    // check to make sure it is not invoked in production.
    function setFeatureFlagForTest(name, value) {
    }
    var featureFlagLookup = {
        ENABLE_REACTIVE_SETTER: null,
        ENABLE_HMR: null,
        // Flag to toggle on/off the enforcement of innerText/outerText shadow dom semantic in elements when using synthetic shadow.
        // Note: Once active, elements outside the lwc boundary are controlled by the ENABLE_ELEMENT_PATCH flag.
        ENABLE_INNER_OUTER_TEXT_PATCH: null,
        // Flags to toggle on/off the enforcement of shadow dom semantic in element/node outside lwc boundary when using synthetic shadow.
        ENABLE_ELEMENT_PATCH: null,
        ENABLE_NODE_LIST_PATCH: null,
        ENABLE_HTML_COLLECTIONS_PATCH: null,
        ENABLE_NODE_PATCH: null,
        // Disables the fix for #2121 where non-composed events are visible outside of their shadow root.
        ENABLE_NON_COMPOSED_EVENTS_LEAKAGE: null,
        ENABLE_LIGHT_DOM_COMPONENTS: null
    };
    /** version: 2.1.2 */
    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // This is a temporary workaround to get the @lwc/engine-server to evaluate in node without having
    // to inject at runtime.
    var HTMLElementConstructor$1 = typeof HTMLElement !== 'undefined' ? HTMLElement : function () { };
    var HTMLElementPrototype = HTMLElementConstructor$1.prototype;
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This is a descriptor map that contains
     * all standard properties that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base HTML Element and
     * Base Lightning Element should support.
     */
    var HTMLElementOriginalDescriptors = create$2(null);
    forEach.call(keys$1(AriaPropNameToAttrNameMap), function (propName) {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, some properties are on Element.prototype instead of HTMLElement, just to be sure.
        var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
        if (!isUndefined$3(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    forEach.call(defaultDefHTMLPropertyNames, function (propName) {
        // Note: intentionally using our in-house getPropertyDescriptor instead of getOwnPropertyDescriptor here because
        // in IE11, id property is on Element.prototype instead of HTMLElement, and we suspect that more will fall into
        // this category, so, better to be sure.
        var descriptor = getPropertyDescriptor(HTMLElementPrototype, propName);
        if (!isUndefined$3(descriptor)) {
            HTMLElementOriginalDescriptors[propName] = descriptor;
        }
    });
    /**
     * Copyright (C) 2017 salesforce.com, inc.
     */
    var isArray = Array.isArray;
    var getPrototypeOf = Object.getPrototypeOf, ObjectCreate = Object.create, ObjectDefineProperty = Object.defineProperty, isExtensible = Object.isExtensible, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, preventExtensions = Object.preventExtensions, hasOwnProperty = Object.hasOwnProperty;
    var _k = Array.prototype, ArrayPush = _k.push, ArrayConcat = _k.concat;
    function isUndefined(obj) {
        return obj === undefined;
    }
    function isFunction(obj) {
        return typeof obj === 'function';
    }
    var proxyToValueMap = new WeakMap();
    function registerProxy(proxy, value) {
        proxyToValueMap.set(proxy, value);
    }
    var unwrap$1 = function (replicaOrAny) { return proxyToValueMap.get(replicaOrAny) || replicaOrAny; };
    var BaseProxyHandler = /** @class */ (function () {
        function BaseProxyHandler(membrane, value) {
            this.originalTarget = value;
            this.membrane = membrane;
        } // Shared utility methods
        BaseProxyHandler.prototype.wrapDescriptor = function (descriptor) {
            if (hasOwnProperty.call(descriptor, 'value')) {
                descriptor.value = this.wrapValue(descriptor.value);
            }
            else {
                var originalSet = descriptor.set, originalGet = descriptor.get;
                if (!isUndefined(originalGet)) {
                    descriptor.get = this.wrapGetter(originalGet);
                }
                if (!isUndefined(originalSet)) {
                    descriptor.set = this.wrapSetter(originalSet);
                }
            }
            return descriptor;
        };
        BaseProxyHandler.prototype.copyDescriptorIntoShadowTarget = function (shadowTarget, key) {
            var originalTarget = this.originalTarget; // Note: a property might get defined multiple times in the shadowTarget
            //       but it will always be compatible with the previous descriptor
            //       to preserve the object invariants, which makes these lines safe.
            var originalDescriptor = getOwnPropertyDescriptor(originalTarget, key);
            if (!isUndefined(originalDescriptor)) {
                var wrappedDesc = this.wrapDescriptor(originalDescriptor);
                ObjectDefineProperty(shadowTarget, key, wrappedDesc);
            }
        };
        BaseProxyHandler.prototype.lockShadowTarget = function (shadowTarget) {
            var _this = this;
            var originalTarget = this.originalTarget;
            var targetKeys = ArrayConcat.call(getOwnPropertyNames(originalTarget), getOwnPropertySymbols(originalTarget));
            targetKeys.forEach(function (key) {
                _this.copyDescriptorIntoShadowTarget(shadowTarget, key);
            });
            var tagPropertyKey = this.membrane.tagPropertyKey;
            if (!isUndefined(tagPropertyKey) && !hasOwnProperty.call(shadowTarget, tagPropertyKey)) {
                ObjectDefineProperty(shadowTarget, tagPropertyKey, ObjectCreate(null));
            }
            preventExtensions(shadowTarget);
        }; // Shared Traps
        BaseProxyHandler.prototype.apply = function (shadowTarget, thisArg, argArray) {
            /* No op */
        };
        BaseProxyHandler.prototype.construct = function (shadowTarget, argArray, newTarget) {
            /* No op */
        };
        BaseProxyHandler.prototype.get = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueObserved = _b.membrane.valueObserved;
            var value = originalTarget[key];
            valueObserved(originalTarget, key);
            return this.wrapValue(value);
        };
        BaseProxyHandler.prototype.has = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, _c = _b.membrane, tagPropertyKey = _c.tagPropertyKey, valueObserved = _c.valueObserved;
            valueObserved(originalTarget, key); // since key is never going to be undefined, and tagPropertyKey might be undefined
            // we can simply compare them as the second part of the condition.
            return key in originalTarget || key === tagPropertyKey;
        };
        BaseProxyHandler.prototype.ownKeys = function (shadowTarget) {
            var _b = this, originalTarget = _b.originalTarget, tagPropertyKey = _b.membrane.tagPropertyKey; // if the membrane tag key exists and it is not in the original target, we add it to the keys.
            var keys = isUndefined(tagPropertyKey) || hasOwnProperty.call(originalTarget, tagPropertyKey) ? [] : [tagPropertyKey]; // small perf optimization using push instead of concat to avoid creating an extra array
            ArrayPush.apply(keys, getOwnPropertyNames(originalTarget));
            ArrayPush.apply(keys, getOwnPropertySymbols(originalTarget));
            return keys;
        };
        BaseProxyHandler.prototype.isExtensible = function (shadowTarget) {
            var originalTarget = this.originalTarget; // optimization to avoid attempting to lock down the shadowTarget multiple times
            if (!isExtensible(shadowTarget)) {
                return false; // was already locked down
            }
            if (!isExtensible(originalTarget)) {
                this.lockShadowTarget(shadowTarget);
                return false;
            }
            return true;
        };
        BaseProxyHandler.prototype.getPrototypeOf = function (shadowTarget) {
            var originalTarget = this.originalTarget;
            return getPrototypeOf(originalTarget);
        };
        BaseProxyHandler.prototype.getOwnPropertyDescriptor = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, _c = _b.membrane, valueObserved = _c.valueObserved, tagPropertyKey = _c.tagPropertyKey; // keys looked up via getOwnPropertyDescriptor need to be reactive
            valueObserved(originalTarget, key);
            var desc = getOwnPropertyDescriptor(originalTarget, key);
            if (isUndefined(desc)) {
                if (key !== tagPropertyKey) {
                    return undefined;
                } // if the key is the membrane tag key, and is not in the original target,
                // we produce a synthetic descriptor and install it on the shadow target
                desc = {
                    value: undefined,
                    writable: false,
                    configurable: false,
                    enumerable: false
                };
                ObjectDefineProperty(shadowTarget, tagPropertyKey, desc);
                return desc;
            }
            if (desc.configurable === false) {
                // updating the descriptor to non-configurable on the shadow
                this.copyDescriptorIntoShadowTarget(shadowTarget, key);
            } // Note: by accessing the descriptor, the key is marked as observed
            // but access to the value, setter or getter (if available) cannot observe
            // mutations, just like regular methods, in which case we just do nothing.
            return this.wrapDescriptor(desc);
        };
        return BaseProxyHandler;
    }());
    var getterMap = new WeakMap();
    var setterMap = new WeakMap();
    var reverseGetterMap = new WeakMap();
    var reverseSetterMap = new WeakMap();
    var ReactiveProxyHandler = /** @class */ (function (_super) {
        __extends(ReactiveProxyHandler, _super);
        function ReactiveProxyHandler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReactiveProxyHandler.prototype.wrapValue = function (value) {
            return this.membrane.getProxy(value);
        };
        ReactiveProxyHandler.prototype.wrapGetter = function (originalGet) {
            var wrappedGetter = getterMap.get(originalGet);
            if (!isUndefined(wrappedGetter)) {
                return wrappedGetter;
            }
            var handler = this;
            var get = function () {
                // invoking the original getter with the original target
                return handler.wrapValue(originalGet.call(unwrap$1(this)));
            };
            getterMap.set(originalGet, get);
            reverseGetterMap.set(get, originalGet);
            return get;
        };
        ReactiveProxyHandler.prototype.wrapSetter = function (originalSet) {
            var wrappedSetter = setterMap.get(originalSet);
            if (!isUndefined(wrappedSetter)) {
                return wrappedSetter;
            }
            var set = function (v) {
                // invoking the original setter with the original target
                originalSet.call(unwrap$1(this), unwrap$1(v));
            };
            setterMap.set(originalSet, set);
            reverseSetterMap.set(set, originalSet);
            return set;
        };
        ReactiveProxyHandler.prototype.unwrapDescriptor = function (descriptor) {
            if (hasOwnProperty.call(descriptor, 'value')) {
                // dealing with a data descriptor
                descriptor.value = unwrap$1(descriptor.value);
            }
            else {
                var set = descriptor.set, get = descriptor.get;
                if (!isUndefined(get)) {
                    descriptor.get = this.unwrapGetter(get);
                }
                if (!isUndefined(set)) {
                    descriptor.set = this.unwrapSetter(set);
                }
            }
            return descriptor;
        };
        ReactiveProxyHandler.prototype.unwrapGetter = function (redGet) {
            var reverseGetter = reverseGetterMap.get(redGet);
            if (!isUndefined(reverseGetter)) {
                return reverseGetter;
            }
            var handler = this;
            var get = function () {
                // invoking the red getter with the proxy of this
                return unwrap$1(redGet.call(handler.wrapValue(this)));
            };
            getterMap.set(get, redGet);
            reverseGetterMap.set(redGet, get);
            return get;
        };
        ReactiveProxyHandler.prototype.unwrapSetter = function (redSet) {
            var reverseSetter = reverseSetterMap.get(redSet);
            if (!isUndefined(reverseSetter)) {
                return reverseSetter;
            }
            var handler = this;
            var set = function (v) {
                // invoking the red setter with the proxy of this
                redSet.call(handler.wrapValue(this), handler.wrapValue(v));
            };
            setterMap.set(set, redSet);
            reverseSetterMap.set(redSet, set);
            return set;
        };
        ReactiveProxyHandler.prototype.set = function (shadowTarget, key, value) {
            var _b = this, originalTarget = _b.originalTarget, valueMutated = _b.membrane.valueMutated;
            var oldValue = originalTarget[key];
            if (oldValue !== value) {
                originalTarget[key] = value;
                valueMutated(originalTarget, key);
            }
            else if (key === 'length' && isArray(originalTarget)) {
                // fix for issue #236: push will add the new index, and by the time length
                // is updated, the internal length is already equal to the new length value
                // therefore, the oldValue is equal to the value. This is the forking logic
                // to support this use case.
                valueMutated(originalTarget, key);
            }
            return true;
        };
        ReactiveProxyHandler.prototype.deleteProperty = function (shadowTarget, key) {
            var _b = this, originalTarget = _b.originalTarget, valueMutated = _b.membrane.valueMutated;
            delete originalTarget[key];
            valueMutated(originalTarget, key);
            return true;
        };
        ReactiveProxyHandler.prototype.setPrototypeOf = function (shadowTarget, prototype) {
        };
        ReactiveProxyHandler.prototype.preventExtensions = function (shadowTarget) {
            if (isExtensible(shadowTarget)) {
                var originalTarget = this.originalTarget;
                preventExtensions(originalTarget); // if the originalTarget is a proxy itself, it might reject
                // the preventExtension call, in which case we should not attempt to lock down
                // the shadow target.
                if (isExtensible(originalTarget)) {
                    return false;
                }
                this.lockShadowTarget(shadowTarget);
            }
            return true;
        };
        ReactiveProxyHandler.prototype.defineProperty = function (shadowTarget, key, descriptor) {
            var _b = this, originalTarget = _b.originalTarget, _c = _b.membrane, valueMutated = _c.valueMutated, tagPropertyKey = _c.tagPropertyKey;
            if (key === tagPropertyKey && !hasOwnProperty.call(originalTarget, key)) {
                // To avoid leaking the membrane tag property into the original target, we must
                // be sure that the original target doesn't have yet.
                // NOTE: we do not return false here because Object.freeze and equivalent operations
                // will attempt to set the descriptor to the same value, and expect no to throw. This
                // is an small compromise for the sake of not having to diff the descriptors.
                return true;
            }
            ObjectDefineProperty(originalTarget, key, this.unwrapDescriptor(descriptor)); // intentionally testing if false since it could be undefined as well
            if (descriptor.configurable === false) {
                this.copyDescriptorIntoShadowTarget(shadowTarget, key);
            }
            valueMutated(originalTarget, key);
            return true;
        };
        return ReactiveProxyHandler;
    }(BaseProxyHandler));
    var getterMap$1 = new WeakMap();
    var setterMap$1 = new WeakMap();
    var ReadOnlyHandler = /** @class */ (function (_super) {
        __extends(ReadOnlyHandler, _super);
        function ReadOnlyHandler() {
            return _super !== null && _super.apply(this, arguments) || this;
        }
        ReadOnlyHandler.prototype.wrapValue = function (value) {
            return this.membrane.getReadOnlyProxy(value);
        };
        ReadOnlyHandler.prototype.wrapGetter = function (originalGet) {
            var wrappedGetter = getterMap$1.get(originalGet);
            if (!isUndefined(wrappedGetter)) {
                return wrappedGetter;
            }
            var handler = this;
            var get = function () {
                // invoking the original getter with the original target
                return handler.wrapValue(originalGet.call(unwrap$1(this)));
            };
            getterMap$1.set(originalGet, get);
            return get;
        };
        ReadOnlyHandler.prototype.wrapSetter = function (originalSet) {
            var wrappedSetter = setterMap$1.get(originalSet);
            if (!isUndefined(wrappedSetter)) {
                return wrappedSetter;
            }
            var set = function (v) {
            };
            setterMap$1.set(originalSet, set);
            return set;
        };
        ReadOnlyHandler.prototype.set = function (shadowTarget, key, value) {
            return false;
        };
        ReadOnlyHandler.prototype.deleteProperty = function (shadowTarget, key) {
            return false;
        };
        ReadOnlyHandler.prototype.setPrototypeOf = function (shadowTarget, prototype) {
        };
        ReadOnlyHandler.prototype.preventExtensions = function (shadowTarget) {
            return false;
        };
        ReadOnlyHandler.prototype.defineProperty = function (shadowTarget, key, descriptor) {
            return false;
        };
        return ReadOnlyHandler;
    }(BaseProxyHandler));
    var ObjectDotPrototype = Object.prototype;
    function defaultValueIsObservable(value) {
        // intentionally checking for null
        if (value === null) {
            return false;
        } // treat all non-object types, including undefined, as non-observable values
        if (typeof value !== 'object') {
            return false;
        }
        if (isArray(value)) {
            return true;
        }
        var proto = getPrototypeOf(value);
        return proto === ObjectDotPrototype || proto === null || getPrototypeOf(proto) === null;
    }
    var defaultValueObserved = function (obj, key) {
        /* do nothing */
    };
    var defaultValueMutated = function (obj, key) {
        /* do nothing */
    };
    var defaultValueDistortion = function (value) { return value; };
    function createShadowTarget(value) {
        return isArray(value) ? [] : {};
    }
    var ReactiveMembrane = /** @class */ (function () {
        function ReactiveMembrane(options) {
            this.valueDistortion = defaultValueDistortion;
            this.valueMutated = defaultValueMutated;
            this.valueObserved = defaultValueObserved;
            this.valueIsObservable = defaultValueIsObservable;
            this.objectGraph = new WeakMap();
            if (!isUndefined(options)) {
                var valueDistortion_1 = options.valueDistortion, valueMutated_1 = options.valueMutated, valueObserved_1 = options.valueObserved, valueIsObservable = options.valueIsObservable, tagPropertyKey = options.tagPropertyKey;
                this.valueDistortion = isFunction(valueDistortion_1) ? valueDistortion_1 : defaultValueDistortion;
                this.valueMutated = isFunction(valueMutated_1) ? valueMutated_1 : defaultValueMutated;
                this.valueObserved = isFunction(valueObserved_1) ? valueObserved_1 : defaultValueObserved;
                this.valueIsObservable = isFunction(valueIsObservable) ? valueIsObservable : defaultValueIsObservable;
                this.tagPropertyKey = tagPropertyKey;
            }
        }
        ReactiveMembrane.prototype.getProxy = function (value) {
            var unwrappedValue = unwrap$1(value);
            var distorted = this.valueDistortion(unwrappedValue);
            if (this.valueIsObservable(distorted)) {
                var o = this.getReactiveState(unwrappedValue, distorted); // when trying to extract the writable version of a readonly
                // we return the readonly.
                return o.readOnly === value ? value : o.reactive;
            }
            return distorted;
        };
        ReactiveMembrane.prototype.getReadOnlyProxy = function (value) {
            value = unwrap$1(value);
            var distorted = this.valueDistortion(value);
            if (this.valueIsObservable(distorted)) {
                return this.getReactiveState(value, distorted).readOnly;
            }
            return distorted;
        };
        ReactiveMembrane.prototype.unwrapProxy = function (p) {
            return unwrap$1(p);
        };
        ReactiveMembrane.prototype.getReactiveState = function (value, distortedValue) {
            var objectGraph = this.objectGraph;
            var reactiveState = objectGraph.get(distortedValue);
            if (reactiveState) {
                return reactiveState;
            }
            var membrane = this;
            reactiveState = {
                get reactive() {
                    var reactiveHandler = new ReactiveProxyHandler(membrane, distortedValue); // caching the reactive proxy after the first time it is accessed
                    var proxy = new Proxy(createShadowTarget(distortedValue), reactiveHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'reactive', {
                        value: proxy
                    });
                    return proxy;
                },
                get readOnly() {
                    var readOnlyHandler = new ReadOnlyHandler(membrane, distortedValue); // caching the readOnly proxy after the first time it is accessed
                    var proxy = new Proxy(createShadowTarget(distortedValue), readOnlyHandler);
                    registerProxy(proxy, value);
                    ObjectDefineProperty(this, 'readOnly', {
                        value: proxy
                    });
                    return proxy;
                }
            };
            objectGraph.set(distortedValue, reactiveState);
            return reactiveState;
        };
        return ReactiveMembrane;
    }());
    /** version: 1.0.0 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var lockerLivePropertyKey = Symbol.for('@@lockerLiveValue');
    function valueDistortion(value) {
        return value;
    }
    var reactiveMembrane = new ReactiveMembrane({
        valueObserved: valueObserved,
        valueMutated: valueMutated,
        valueDistortion: valueDistortion,
        tagPropertyKey: lockerLivePropertyKey
    });
    /**
     * EXPERIMENTAL: This function implements an unwrap mechanism that
     * works for observable membrane objects. This API is subject to
     * change or being removed.
     */
    var unwrap = function (value) {
        var unwrapped = reactiveMembrane.unwrapProxy(value);
        if (unwrapped !== value) {
            // if value is a proxy, unwrap to access original value and apply distortion
            return valueDistortion(unwrapped);
        }
        return value;
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This operation is called with a descriptor of an standard html property
     * that a Custom Element can support (including AOM properties), which
     * determines what kind of capabilities the Base Lightning Element should support. When producing the new descriptors
     * for the Base Lightning Element, it also include the reactivity bit, so the standard property is reactive.
     */
    function createBridgeToElementDescriptor(propName, descriptor) {
        var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        if (!isFunction$1(get)) {
            throw new TypeError();
        }
        if (!isFunction$1(set)) {
            throw new TypeError();
        }
        return {
            enumerable: enumerable,
            configurable: configurable,
            get: function () {
                var vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    return;
                }
                componentValueObserved(vm, propName);
                return get.call(vm.elm);
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (newValue !== vm.cmpProps[propName]) {
                    vm.cmpProps[propName] = newValue;
                    componentValueMutated(vm, propName);
                }
                return set.call(vm.elm, newValue);
            }
        };
    }
    /**
     * This class is the base class for any LWC element.
     * Some elements directly extends this class, others implement it via inheritance.
     **/
    // @ts-ignore
    var LightningElement = function () {
        if (isNull(vmBeingConstructed)) {
            throw new ReferenceError('Illegal constructor');
        }
        var vm = vmBeingConstructed;
        var elm = vm.elm; vm.renderer; var _b = vm.def, ctor = _b.ctor, bridge = _b.bridge;
        var component = this;
        setPrototypeOf$1(elm, bridge.prototype);
        vm.component = this; // Locker hooks assignment. When the LWC engine run with Locker, Locker intercepts all the new
        // component creation and passes hooks to instrument all the component interactions with the
        // engine. We are intentionally hiding this argument from the formal API of LightningElement
        // because we don't want folks to know about it just yet.
        if (arguments.length === 1) {
            var _c = arguments[0], callHook_1 = _c.callHook, setHook_1 = _c.setHook, getHook_1 = _c.getHook;
            vm.callHook = callHook_1;
            vm.setHook = setHook_1;
            vm.getHook = getHook_1;
        } // Making the component instance a live value when using Locker to support expandos.
        defineProperty$1(component, lockerLivePropertyKey, EmptyObject); // Linking elm, shadow root and component with the VM.
        associateVM(component, vm);
        associateVM(elm, vm);
        if (!runtimeFlags.ENABLE_LIGHT_DOM_COMPONENTS) {
            assert.isTrue(ctor.renderMode !== 'light', (ctor.name || 'Anonymous class') + " is an invalid LWC component. Light DOM components are not available in this environment.");
        }
        if (ctor.renderMode !== 'light') {
            attachShadow(vm);
        } // Adding extra guard rails in DEV mode.
        return this;
    };
    function attachShadow(vm) {
        var elm = vm.elm, mode = vm.mode, renderer = vm.renderer, ctor = vm.def.ctor;
        var cmpRoot = renderer.attachShadow(elm, {
            mode: mode,
            delegatesFocus: !!ctor.delegatesFocus,
            '$$lwc-synthetic-mode$$': true
        });
        vm.cmpRoot = cmpRoot;
        associateVM(cmpRoot, vm);
    } // @ts-ignore
    LightningElement.prototype = {
        constructor: LightningElement,
        dispatchEvent: function (event) {
            var _b = getAssociatedVM(this), elm = _b.elm, dispatchEvent = _b.renderer.dispatchEvent;
            return dispatchEvent(elm, event);
        },
        addEventListener: function (type, listener, options) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, addEventListener = vm.renderer.addEventListener;
            var wrappedListener = getWrappedComponentsListener(vm, listener);
            addEventListener(elm, type, wrappedListener, options);
        },
        removeEventListener: function (type, listener, options) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, removeEventListener = vm.renderer.removeEventListener;
            var wrappedListener = getWrappedComponentsListener(vm, listener);
            removeEventListener(elm, type, wrappedListener, options);
        },
        hasAttribute: function (name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return !isNull(getAttribute(elm, name));
        },
        hasAttributeNS: function (namespace, name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return !isNull(getAttribute(elm, name, namespace));
        },
        removeAttribute: function (name) {
            var _b = getAssociatedVM(this), elm = _b.elm, removeAttribute = _b.renderer.removeAttribute;
            unlockAttribute(elm, name);
            removeAttribute(elm, name);
            lockAttribute();
        },
        removeAttributeNS: function (namespace, name) {
            var _b = getAssociatedVM(this), elm = _b.elm, removeAttribute = _b.renderer.removeAttribute;
            unlockAttribute(elm, name);
            removeAttribute(elm, name, namespace);
            lockAttribute();
        },
        getAttribute: function (name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return getAttribute(elm, name);
        },
        getAttributeNS: function (namespace, name) {
            var _b = getAssociatedVM(this), elm = _b.elm, getAttribute = _b.renderer.getAttribute;
            return getAttribute(elm, name, namespace);
        },
        setAttribute: function (name, value) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, setAttribute = vm.renderer.setAttribute;
            unlockAttribute(elm, name);
            setAttribute(elm, name, value);
            lockAttribute();
        },
        setAttributeNS: function (namespace, name, value) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, setAttribute = vm.renderer.setAttribute;
            unlockAttribute(elm, name);
            setAttribute(elm, name, value, namespace);
            lockAttribute();
        },
        getBoundingClientRect: function () {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getBoundingClientRect = vm.renderer.getBoundingClientRect;
            return getBoundingClientRect(elm);
        },
        querySelector: function (selectors) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, querySelector = vm.renderer.querySelector;
            return querySelector(elm, selectors);
        },
        querySelectorAll: function (selectors) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, querySelectorAll = vm.renderer.querySelectorAll;
            return querySelectorAll(elm, selectors);
        },
        getElementsByTagName: function (tagNameOrWildCard) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getElementsByTagName = vm.renderer.getElementsByTagName;
            return getElementsByTagName(elm, tagNameOrWildCard);
        },
        getElementsByClassName: function (names) {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getElementsByClassName = vm.renderer.getElementsByClassName;
            return getElementsByClassName(elm, names);
        },
        get isConnected() {
            var _b = getAssociatedVM(this), elm = _b.elm, isConnected = _b.renderer.isConnected;
            return isConnected(elm);
        },
        get classList() {
            var vm = getAssociatedVM(this);
            var elm = vm.elm, getClassList = vm.renderer.getClassList;
            return getClassList(elm);
        },
        get template() {
            var vm = getAssociatedVM(this);
            return vm.cmpRoot;
        },
        get shadowRoot() {
            // From within the component instance, the shadowRoot is always reported as "closed".
            // Authors should rely on this.template instead.
            return null;
        },
        render: function () {
            var vm = getAssociatedVM(this);
            return vm.def.template;
        },
        toString: function () {
            var vm = getAssociatedVM(this);
            return "[object " + vm.def.name + "]";
        }
    };
    var lightningBasedDescriptors = create$2(null);
    for (var propName in HTMLElementOriginalDescriptors) {
        lightningBasedDescriptors[propName] = createBridgeToElementDescriptor(propName, HTMLElementOriginalDescriptors[propName]);
    }
    defineProperties$1(LightningElement.prototype, lightningBasedDescriptors);
    defineProperty$1(LightningElement, 'CustomElementConstructor', {
        get: function () {
            // If required, a runtime-specific implementation must be defined.
            throw new ReferenceError('The current runtime does not support CustomElementConstructor.');
        },
        configurable: true
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * @wire decorator to wire fields and methods to a wire adapter in
     * LWC Components. This function implements the internals of this
     * decorator.
     */
    function wire(_adapter, _config) {
        throw new Error();
    }
    function internalWireFieldDecorator(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (value) {
                var vm = getAssociatedVM(this);
                /**
                 * Reactivity for wired fields is provided in wiring.
                 * We intentionally add reactivity here since this is just
                 * letting the author to do the wrong thing, but it will keep our
                 * system to be backward compatible.
                 */
                if (value !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = value;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function track(target) {
        if (arguments.length === 1) {
            return reactiveMembrane.getProxy(target);
        }
        throw new Error();
    }
    function internalTrackDecorator(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                var reactiveOrAnyValue = reactiveMembrane.getProxy(newValue);
                if (reactiveOrAnyValue !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = reactiveOrAnyValue;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function api$1() {
        throw new Error();
    }
    function createPublicPropertyDescriptor(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                if (isBeingConstructed(vm)) {
                    return;
                }
                componentValueObserved(vm, key);
                return vm.cmpProps[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                vm.cmpProps[key] = newValue;
                componentValueMutated(vm, key);
            },
            enumerable: true,
            configurable: true
        };
    }
    var AccessorReactiveObserver = /** @class */ (function (_super) {
        __extends(AccessorReactiveObserver, _super);
        function AccessorReactiveObserver(vm, set) {
            var _this = _super.call(this, function () {
                if (isFalse$2(_this.debouncing)) {
                    _this.debouncing = true;
                    addCallbackToNextTick(function () {
                        if (isTrue$2(_this.debouncing)) {
                            var value = _this.value;
                            var dirtyStateBeforeSetterCall = vm.isDirty, component = vm.component, idx_1 = vm.idx;
                            set.call(component, value); // de-bouncing after the call to the original setter to prevent
                            // infinity loop if the setter itself is mutating things that
                            // were accessed during the previous invocation.
                            _this.debouncing = false;
                            if (isTrue$2(vm.isDirty) && isFalse$2(dirtyStateBeforeSetterCall) && idx_1 > 0) {
                                // immediate rehydration due to a setter driven mutation, otherwise
                                // the component will get rendered on the second tick, which it is not
                                // desirable.
                                rerenderVM(vm);
                            }
                        }
                    });
                }
            }) || this;
            _this.debouncing = false;
            return _this;
        }
        AccessorReactiveObserver.prototype.reset = function (value) {
            _super.prototype.reset.call(this);
            this.debouncing = false;
            if (arguments.length > 0) {
                this.value = value;
            }
        };
        return AccessorReactiveObserver;
    }(ReactiveObserver));
    function createPublicAccessorDescriptor(key, descriptor) {
        var get = descriptor.get, set = descriptor.set, enumerable = descriptor.enumerable, configurable = descriptor.configurable;
        if (!isFunction$1(get)) {
            throw new Error();
        }
        return {
            get: function () {
                return get.call(this);
            },
            set: function (newValue) {
                var _this = this;
                var vm = getAssociatedVM(this);
                if (set) {
                    if (runtimeFlags.ENABLE_REACTIVE_SETTER) {
                        var ro = vm.oar[key];
                        if (isUndefined$3(ro)) {
                            ro = vm.oar[key] = new AccessorReactiveObserver(vm, set);
                        } // every time we invoke this setter from outside (through this wrapper setter)
                        // we should reset the value and then debounce just in case there is a pending
                        // invocation the next tick that is not longer relevant since the value is changing
                        // from outside.
                        ro.reset(newValue);
                        ro.observe(function () {
                            set.call(_this, newValue);
                        });
                    }
                    else {
                        set.call(this, newValue);
                    }
                }
            },
            enumerable: enumerable,
            configurable: configurable
        };
    }
    function createObservedFieldPropertyDescriptor(key) {
        return {
            get: function () {
                var vm = getAssociatedVM(this);
                componentValueObserved(vm, key);
                return vm.cmpFields[key];
            },
            set: function (newValue) {
                var vm = getAssociatedVM(this);
                if (newValue !== vm.cmpFields[key]) {
                    vm.cmpFields[key] = newValue;
                    componentValueMutated(vm, key);
                }
            },
            enumerable: true,
            configurable: true
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var PropType;
    (function (PropType) {
        PropType[PropType["Field"] = 0] = "Field";
        PropType[PropType["Set"] = 1] = "Set";
        PropType[PropType["Get"] = 2] = "Get";
        PropType[PropType["GetSet"] = 3] = "GetSet";
    })(PropType || (PropType = {}));
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by user-land code.
     */
    function registerDecorators(Ctor, meta) {
        var proto = Ctor.prototype;
        var publicProps = meta.publicProps, publicMethods = meta.publicMethods, wire = meta.wire, track = meta.track, fields = meta.fields;
        var apiMethods = create$2(null);
        var apiFields = create$2(null);
        var wiredMethods = create$2(null);
        var wiredFields = create$2(null);
        var observedFields = create$2(null);
        var apiFieldsConfig = create$2(null);
        var descriptor;
        if (!isUndefined$3(publicProps)) {
            for (var fieldName in publicProps) {
                var propConfig = publicProps[fieldName];
                apiFieldsConfig[fieldName] = propConfig.config;
                descriptor = getOwnPropertyDescriptor$2(proto, fieldName);
                if (propConfig.config > 0) {
                    if (isUndefined$3(descriptor)) {
                        throw new Error();
                    }
                    descriptor = createPublicAccessorDescriptor(fieldName, descriptor);
                }
                else {
                    descriptor = createPublicPropertyDescriptor(fieldName);
                }
                apiFields[fieldName] = descriptor;
                defineProperty$1(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined$3(publicMethods)) {
            forEach.call(publicMethods, function (methodName) {
                descriptor = getOwnPropertyDescriptor$2(proto, methodName);
                if (isUndefined$3(descriptor)) {
                    throw new Error();
                }
                apiMethods[methodName] = descriptor;
            });
        }
        if (!isUndefined$3(wire)) {
            for (var fieldOrMethodName in wire) {
                var _b = wire[fieldOrMethodName], adapter = _b.adapter, method = _b.method, configCallback = _b.config, _c = _b.dynamic, dynamic = _c === void 0 ? [] : _c;
                descriptor = getOwnPropertyDescriptor$2(proto, fieldOrMethodName);
                if (method === 1) {
                    if (isUndefined$3(descriptor)) {
                        throw new Error();
                    }
                    wiredMethods[fieldOrMethodName] = descriptor;
                    storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic);
                }
                else {
                    descriptor = internalWireFieldDecorator(fieldOrMethodName);
                    wiredFields[fieldOrMethodName] = descriptor;
                    storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic);
                    defineProperty$1(proto, fieldOrMethodName, descriptor);
                }
            }
        }
        if (!isUndefined$3(track)) {
            for (var fieldName in track) {
                descriptor = getOwnPropertyDescriptor$2(proto, fieldName);
                descriptor = internalTrackDecorator(fieldName);
                defineProperty$1(proto, fieldName, descriptor);
            }
        }
        if (!isUndefined$3(fields)) {
            for (var i_9 = 0, n = fields.length; i_9 < n; i_9++) {
                var fieldName = fields[i_9];
                descriptor = getOwnPropertyDescriptor$2(proto, fieldName);
                observedFields[fieldName] = createObservedFieldPropertyDescriptor(fieldName);
            }
        }
        setDecoratorsMeta(Ctor, {
            apiMethods: apiMethods,
            apiFields: apiFields,
            apiFieldsConfig: apiFieldsConfig,
            wiredMethods: wiredMethods,
            wiredFields: wiredFields,
            observedFields: observedFields
        });
        return Ctor;
    }
    var signedDecoratorToMetaMap = new Map();
    function setDecoratorsMeta(Ctor, meta) {
        signedDecoratorToMetaMap.set(Ctor, meta);
    }
    var defaultMeta = {
        apiMethods: EmptyObject,
        apiFields: EmptyObject,
        apiFieldsConfig: EmptyObject,
        wiredMethods: EmptyObject,
        wiredFields: EmptyObject,
        observedFields: EmptyObject
    };
    function getDecoratorsMeta(Ctor) {
        var meta = signedDecoratorToMetaMap.get(Ctor);
        return isUndefined$3(meta) ? defaultMeta : meta;
    }
    var signedTemplateSet = new Set();
    function defaultEmptyTemplate() {
        return [];
    }
    signedTemplateSet.add(defaultEmptyTemplate);
    function isTemplateRegistered(tpl) {
        return signedTemplateSet.has(tpl);
    }
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerTemplate(tpl) {
        signedTemplateSet.add(tpl); // chaining this method as a way to wrap existing
        // assignment of templates easily, without too much transformation
        return tpl;
    }
    /**
     * EXPERIMENTAL: This function acts like a hook for Lightning Locker
     * Service and other similar libraries to sanitize vulnerable attributes.
     * This API is subject to change or being removed.
     */
    function sanitizeAttribute(tagName, namespaceUri, attrName, attrValue) {
        // locker-service patches this function during runtime to sanitize vulnerable attributes.
        // when ran off-core this function becomes a noop and returns the user authored value.
        return attrValue;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    // from the element instance, and get the value or set a new value on the component.
    // This means that across different elements, similar names can get the exact same
    // descriptor, so we can cache them:
    var cachedGetterByKey = create$2(null);
    var cachedSetterByKey = create$2(null);
    function createGetter(key) {
        var fn = cachedGetterByKey[key];
        if (isUndefined$3(fn)) {
            fn = cachedGetterByKey[key] = function () {
                var vm = getAssociatedVM(this);
                var getHook = vm.getHook;
                return getHook(vm.component, key);
            };
        }
        return fn;
    }
    function createSetter(key) {
        var fn = cachedSetterByKey[key];
        if (isUndefined$3(fn)) {
            fn = cachedSetterByKey[key] = function (newValue) {
                var vm = getAssociatedVM(this);
                var setHook = vm.setHook;
                newValue = reactiveMembrane.getReadOnlyProxy(newValue);
                setHook(vm.component, key, newValue);
            };
        }
        return fn;
    }
    function createMethodCaller(methodName) {
        return function () {
            var vm = getAssociatedVM(this);
            var callHook = vm.callHook, component = vm.component;
            var fn = component[methodName];
            return callHook(vm.component, fn, ArraySlice.call(arguments));
        };
    }
    function createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback) {
        return function attributeChangedCallback(attrName, oldValue, newValue) {
            if (oldValue === newValue) {
                // Ignore same values.
                return;
            }
            var propName = attributeToPropMap[attrName];
            if (isUndefined$3(propName)) {
                if (!isUndefined$3(superAttributeChangedCallback)) {
                    // delegate unknown attributes to the super.
                    // Typescript does not like it when you treat the `arguments` object as an array
                    // @ts-ignore type-mismatch
                    superAttributeChangedCallback.apply(this, arguments);
                }
                return;
            }
            if (!isAttributeLocked(this, attrName)) {
                // Ignore changes triggered by the engine itself during:
                // * diffing when public props are attempting to reflect to the DOM
                // * component via `this.setAttribute()`, should never update the prop
                // Both cases, the setAttribute call is always wrapped by the unlocking of the
                // attribute to be changed
                return;
            } // Reflect attribute change to the corresponding property when changed from outside.
            this[propName] = newValue;
        };
    }
    function HTMLBridgeElementFactory(SuperClass, props, methods) {
        var HTMLBridgeElement;
        /**
         * Modern browsers will have all Native Constructors as regular Classes
         * and must be instantiated with the new keyword. In older browsers,
         * specifically IE11, those are objects with a prototype property defined,
         * since they are not supposed to be extended or instantiated with the
         * new keyword. This forking logic supports both cases, specifically because
         * wc.ts relies on the construction path of the bridges to create new
         * fully qualifying web components.
         */
        if (isFunction$1(SuperClass)) {
            HTMLBridgeElement = /** @class */ (function (_super) {
                __extends(HTMLBridgeElement, _super);
                function HTMLBridgeElement() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return HTMLBridgeElement;
            }(SuperClass));
        }
        else {
            HTMLBridgeElement = function () {
                // Bridge classes are not supposed to be instantiated directly in
                // browsers that do not support web components.
                throw new TypeError('Illegal constructor');
            }; // prototype inheritance dance
            setPrototypeOf$1(HTMLBridgeElement, SuperClass);
            setPrototypeOf$1(HTMLBridgeElement.prototype, SuperClass.prototype);
            defineProperty$1(HTMLBridgeElement.prototype, 'constructor', {
                writable: true,
                configurable: true,
                value: HTMLBridgeElement
            });
        } // generating the hash table for attributes to avoid duplicate fields and facilitate validation
        // and false positives in case of inheritance.
        var attributeToPropMap = create$2(null);
        var superAttributeChangedCallback = SuperClass.prototype.attributeChangedCallback;
        var _b = SuperClass.observedAttributes, superObservedAttributes = _b === void 0 ? [] : _b;
        var descriptors = create$2(null); // expose getters and setters for each public props on the new Element Bridge
        for (var i_10 = 0, len = props.length; i_10 < len; i_10 += 1) {
            var propName = props[i_10];
            attributeToPropMap[htmlPropertyToAttribute(propName)] = propName;
            descriptors[propName] = {
                get: createGetter(propName),
                set: createSetter(propName),
                enumerable: true,
                configurable: true
            };
        } // expose public methods as props on the new Element Bridge
        for (var i_11 = 0, len = methods.length; i_11 < len; i_11 += 1) {
            var methodName = methods[i_11];
            descriptors[methodName] = {
                value: createMethodCaller(methodName),
                writable: true,
                configurable: true
            };
        } // creating a new attributeChangedCallback per bridge because they are bound to the corresponding
        // map of attributes to props. We do this after all other props and methods to avoid the possibility
        // of getting overrule by a class declaration in user-land, and we make it non-writable, non-configurable
        // to preserve this definition.
        descriptors.attributeChangedCallback = {
            value: createAttributeChangedCallback(attributeToPropMap, superAttributeChangedCallback)
        }; // Specify attributes for which we want to reflect changes back to their corresponding
        // properties via attributeChangedCallback.
        defineProperty$1(HTMLBridgeElement, 'observedAttributes', {
            get: function () {
                return __spreadArray(__spreadArray([], superObservedAttributes), keys$1(attributeToPropMap));
            }
        });
        defineProperties$1(HTMLBridgeElement.prototype, descriptors);
        return HTMLBridgeElement;
    }
    var BaseBridgeElement = HTMLBridgeElementFactory(HTMLElementConstructor$1, getOwnPropertyNames$2(HTMLElementOriginalDescriptors), []);
    freeze$1(BaseBridgeElement);
    seal$1(BaseBridgeElement.prototype);
    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function resolveCircularModuleDependency(fn) {
        return fn();
    }
    function isCircularModuleDependency(obj) {
        return isFunction$1(obj) && hasOwnProperty$2.call(obj, '__circular__');
    }
    function setActiveVM(vm) {
        {
            // this method should never leak to prod
            throw new ReferenceError();
        }
    }
    function swapTemplate(oldTpl, newTpl) {
        if (!runtimeFlags.ENABLE_HMR) {
            throw new Error('HMR is not enabled');
        }
        return false;
    }
    function swapComponent(oldComponent, newComponent) {
        if (!runtimeFlags.ENABLE_HMR) {
            throw new Error('HMR is not enabled');
        }
        return false;
    }
    function swapStyle(oldStyle, newStyle) {
        if (!runtimeFlags.ENABLE_HMR) {
            throw new Error('HMR is not enabled');
        }
        return false;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CtorToDefMap = new WeakMap();
    function getCtorProto(Ctor) {
        var proto = getPrototypeOf$2(Ctor);
        if (isNull(proto)) {
            throw new ReferenceError("Invalid prototype chain for " + Ctor.name + ", you must extend LightningElement.");
        } // covering the cases where the ref is circular in AMD
        if (isCircularModuleDependency(proto)) {
            var p = resolveCircularModuleDependency(proto);
            // of our Base class without having to leak it to user-land. If the circular function returns
            // itself, that's the signal that we have hit the end of the proto chain, which must always
            // be base.
            proto = p === proto ? LightningElement : p;
        }
        return proto;
    }
    function createComponentDef(Ctor) {
        var decoratorsMeta = getDecoratorsMeta(Ctor);
        var apiFields = decoratorsMeta.apiFields, apiFieldsConfig = decoratorsMeta.apiFieldsConfig, apiMethods = decoratorsMeta.apiMethods, wiredFields = decoratorsMeta.wiredFields, wiredMethods = decoratorsMeta.wiredMethods, observedFields = decoratorsMeta.observedFields;
        var proto = Ctor.prototype;
        var connectedCallback = proto.connectedCallback, disconnectedCallback = proto.disconnectedCallback, renderedCallback = proto.renderedCallback, errorCallback = proto.errorCallback, render = proto.render;
        var superProto = getCtorProto(Ctor);
        var superDef = superProto !== LightningElement ? getComponentInternalDef(superProto) : lightingElementDef;
        var bridge = HTMLBridgeElementFactory(superDef.bridge, keys$1(apiFields), keys$1(apiMethods));
        var props = assign$1(create$2(null), superDef.props, apiFields);
        var propsConfig = assign$1(create$2(null), superDef.propsConfig, apiFieldsConfig);
        var methods = assign$1(create$2(null), superDef.methods, apiMethods);
        var wire = assign$1(create$2(null), superDef.wire, wiredFields, wiredMethods);
        connectedCallback = connectedCallback || superDef.connectedCallback;
        disconnectedCallback = disconnectedCallback || superDef.disconnectedCallback;
        renderedCallback = renderedCallback || superDef.renderedCallback;
        errorCallback = errorCallback || superDef.errorCallback;
        render = render || superDef.render;
        var template = getComponentRegisteredTemplate(Ctor) || superDef.template;
        var name = Ctor.name || superDef.name; // installing observed fields into the prototype.
        defineProperties$1(proto, observedFields);
        var def = {
            ctor: Ctor,
            name: name,
            wire: wire,
            props: props,
            propsConfig: propsConfig,
            methods: methods,
            bridge: bridge,
            template: template,
            connectedCallback: connectedCallback,
            disconnectedCallback: disconnectedCallback,
            renderedCallback: renderedCallback,
            errorCallback: errorCallback,
            render: render
        };
        return def;
    }
    /**
     * EXPERIMENTAL: This function allows for the identification of LWC constructors. This API is
     * subject to change or being removed.
     */
    function isComponentConstructor(ctor) {
        if (!isFunction$1(ctor)) {
            return false;
        } // Fast path: LightningElement is part of the prototype chain of the constructor.
        if (ctor.prototype instanceof LightningElement) {
            return true;
        } // Slow path: LightningElement is not part of the prototype chain of the constructor, we need
        // climb up the constructor prototype chain to check in case there are circular dependencies
        // to resolve.
        var current = ctor;
        do {
            if (isCircularModuleDependency(current)) {
                var circularResolved = resolveCircularModuleDependency(current); // If the circular function returns itself, that's the signal that we have hit the end
                // of the proto chain, which must always be a valid base constructor.
                if (circularResolved === current) {
                    return true;
                }
                current = circularResolved;
            }
            if (current === LightningElement) {
                return true;
            }
        } while (!isNull(current) && (current = getPrototypeOf$2(current))); // Finally return false if the LightningElement is not part of the prototype chain.
        return false;
    }
    function getComponentInternalDef(Ctor) {
        var def = CtorToDefMap.get(Ctor);
        if (isUndefined$3(def)) {
            if (isCircularModuleDependency(Ctor)) {
                var resolvedCtor = resolveCircularModuleDependency(Ctor);
                def = getComponentInternalDef(resolvedCtor); // Cache the unresolved component ctor too. The next time if the same unresolved ctor is used,
                // look up the definition in cache instead of re-resolving and recreating the def.
                CtorToDefMap.set(Ctor, def);
                return def;
            }
            if (!isComponentConstructor(Ctor)) {
                throw new TypeError(Ctor + " is not a valid component, or does not extends LightningElement from \"lwc\". You probably forgot to add the extend clause on the class declaration.");
            }
            def = createComponentDef(Ctor);
            CtorToDefMap.set(Ctor, def);
        }
        return def;
    }
    var lightingElementDef = {
        ctor: LightningElement,
        name: LightningElement.name,
        props: lightningBasedDescriptors,
        propsConfig: EmptyObject,
        methods: EmptyObject,
        wire: EmptyObject,
        bridge: BaseBridgeElement,
        template: defaultEmptyTemplate,
        render: LightningElement.prototype.render
    };
    var PropDefType;
    (function (PropDefType) {
        PropDefType["any"] = "any";
    })(PropDefType || (PropDefType = {}));
    /**
     * EXPERIMENTAL: This function allows for the collection of internal component metadata. This API is
     * subject to change or being removed.
     */
    function getComponentDef(Ctor) {
        var def = getComponentInternalDef(Ctor); // From the internal def object, we need to extract the info that is useful
        // for some external services, e.g.: Locker Service, usually, all they care
        // is about the shape of the constructor, the internals of it are not relevant
        // because they don't have a way to mess with that.
        var ctor = def.ctor, name = def.name, props = def.props, propsConfig = def.propsConfig, methods = def.methods;
        var publicProps = {};
        for (var key in props) {
            // avoid leaking the reference to the public props descriptors
            publicProps[key] = {
                config: propsConfig[key] || 0,
                type: PropDefType.any,
                attr: htmlPropertyToAttribute(key)
            };
        }
        var publicMethods = {};
        for (var key in methods) {
            // avoid leaking the reference to the public method descriptors
            publicMethods[key] = methods[key].value;
        }
        return {
            ctor: ctor,
            name: name,
            props: publicProps,
            methods: publicMethods
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var noop$4 = function () { return void 0; };
    function observeElementChildNodes(elm) {
        elm.$domManual$ = true;
    }
    function setElementShadowToken(elm, token) {
        elm.$shadowToken$ = token;
    }
    function updateNodeHook(oldVnode, vnode) {
        var elm = vnode.elm, text = vnode.text, renderer = vnode.owner.renderer;
        if (oldVnode.text !== text) {
            renderer.setText(elm, text);
        }
    }
    function insertNodeHook(vnode, parentNode, referenceNode) {
        var renderer = vnode.owner.renderer;
        renderer.insert(vnode.elm, parentNode, referenceNode);
    }
    function removeNodeHook(vnode, parentNode) {
        var renderer = vnode.owner.renderer;
        renderer.remove(vnode.elm, parentNode);
    }
    function createElmHook(vnode) {
        modEvents.create(vnode); // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
    }
    var LWCDOMMode;
    (function (LWCDOMMode) {
        LWCDOMMode["manual"] = "manual";
    })(LWCDOMMode || (LWCDOMMode = {}));
    function fallbackElmHook(elm, vnode) {
        var owner = vnode.owner;
        if (isTrue$2(owner.renderer.syntheticShadow) && isLightRenderModeVM(owner)) {
            var context = vnode.data.context;
            var shadowAttribute = owner.context.shadowAttribute;
            if (!isUndefined$3(context) && !isUndefined$3(context.lwc) && context.lwc.dom === LWCDOMMode.manual) {
                // this element will now accept any manual content inserted into it
                observeElementChildNodes(elm);
            } // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
        }
        var context; 
    }
    function updateElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function updateChildrenHook(oldVnode, vnode) {
        var children = vnode.children, owner = vnode.owner;
        var fn = hasDynamicChildren(children) ? updateDynamicChildren : updateStaticChildren;
        runWithBoundaryProtection(owner, owner.owner, noop$4, function () {
            fn(vnode.elm, oldVnode.children, children);
        }, noop$4);
    }
    function allocateChildrenHook(vnode, vm) {
        // A component with slots will re-render because:
        // 1- There is a change of the internal state.
        // 2- There is a change on the external api (ex: slots)
        //
        // In case #1, the vnodes in the cmpSlots will be reused since they didn't changed. This routine emptied the
        // slotted children when those VCustomElement were rendered and therefore in subsequent calls to allocate children
        // in a reused VCustomElement, there won't be any slotted children.
        // For those cases, we will use the reference for allocated children stored when rendering the fresh VCustomElement.
        //
        // In case #2, we will always get a fresh VCustomElement.
        var children = vnode.aChildren || vnode.children;
        vm.aChildren = children;
        if (isTrue$2(vm.renderer.syntheticShadow) || !isLightRenderModeVM(vm)) {
            // slow path
            allocateInSlot(vm, children); // save the allocated children in case this vnode is reused.
            vnode.aChildren = children; // every child vnode is now allocated, and the host should receive none directly, it receives them via the shadow!
            vnode.children = EmptyArray;
        }
    }
    function createViewModelHook(elm, vnode) {
        if (!isUndefined$3(getAssociatedVMIfPresent(elm))) {
            // There is a possibility that a custom element is registered under tagName,
            // in which case, the initialization is already carry on, and there is nothing else
            // to do here since this hook is called right after invoking `document.createElement`.
            return;
        }
        var sel = vnode.sel, mode = vnode.mode, ctor = vnode.ctor, owner = vnode.owner;
        var def = getComponentInternalDef(ctor);
        if (isTrue$2(owner.renderer.syntheticShadow) && isLightRenderModeVM(owner)) {
            var shadowAttribute = owner.context.shadowAttribute; // when running in synthetic shadow mode, we need to set the shadowToken value
            // into each element from the template, so they can be styled accordingly.
            setElementShadowToken(elm, shadowAttribute);
        }
        createVM(elm, def, {
            mode: mode,
            owner: owner,
            tagName: sel,
            renderer: owner.renderer
        });
    }
    function createCustomElmHook(vnode) {
        modEvents.create(vnode); // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.create(vnode);
        modProps.create(vnode);
        modStaticClassName.create(vnode);
        modStaticStyle.create(vnode);
        modComputedClassName.create(vnode);
        modComputedStyle.create(vnode);
    }
    function createChildrenHook(vnode) {
        var elm = vnode.elm, children = vnode.children;
        for (var j = 0; j < children.length; ++j) {
            var ch = children[j];
            if (ch != null) {
                ch.hook.create(ch);
                ch.hook.insert(ch, elm, null);
            }
        }
    }
    function updateCustomElmHook(oldVnode, vnode) {
        // Attrs need to be applied to element before props
        // IE11 will wipe out value on radio inputs if value
        // is set before type=radio.
        modAttrs.update(oldVnode, vnode);
        modProps.update(oldVnode, vnode);
        modComputedClassName.update(oldVnode, vnode);
        modComputedStyle.update(oldVnode, vnode);
    }
    function removeElmHook(vnode) {
        // this method only needs to search on child vnodes from template
        // to trigger the remove hook just in case some of those children
        // are custom elements.
        var children = vnode.children, elm = vnode.elm;
        for (var j = 0, len = children.length; j < len; ++j) {
            var ch = children[j];
            if (!isNull(ch)) {
                ch.hook.remove(ch, elm);
            }
        }
    } // Using a WeakMap instead of a WeakSet because this one works in IE11 :(
    var FromIteration = new WeakMap(); // dynamic children means it was generated by an iteration
    // in a template, and will require a more complex diffing algo.
    function markAsDynamicChildren(children) {
        FromIteration.set(children, 1);
    }
    function hasDynamicChildren(children) {
        return FromIteration.has(children);
    }
    /*
     * Copyright (c) 2020, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function getUpgradableConstructor(tagName, renderer) {
        // Should never get a tag with upper case letter at this point, the compiler should
        // produce only tags with lowercase letters
        // But, for backwards compatibility, we will lower case the tagName
        tagName = tagName.toLowerCase();
        var CE = renderer.getCustomElement(tagName);
        if (!isUndefined$3(CE)) {
            return CE;
        }
        /**
         * LWC Upgradable Element reference to an element that was created
         * via the scoped registry mechanism, and that is ready to be upgraded.
         */
        CE = /** @class */ (function (_super) {
            __extends(LWCUpgradableElement, _super);
            function LWCUpgradableElement(upgradeCallback) {
                var _this = _super.call(this) || this;
                if (isFunction$1(upgradeCallback)) {
                    upgradeCallback(_this); // nothing to do with the result for now
                }
                return _this;
            }
            return LWCUpgradableElement;
        }(renderer.HTMLElement));
        renderer.defineCustomElement(tagName, CE);
        return CE;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var CHAR_S = 115;
    var CHAR_V = 118;
    var CHAR_G = 103;
    var NamespaceAttributeForSVG = 'http://www.w3.org/2000/svg';
    var SymbolIterator = Symbol.iterator;
    var TextHook = {
        create: function (vnode) {
            var owner = vnode.owner;
            var renderer = owner.renderer;
            var elm = renderer.createText(vnode.text);
            linkNodeToShadowIfRequired(elm, owner);
            vnode.elm = elm;
        },
        update: updateNodeHook,
        insert: insertNodeHook,
        move: insertNodeHook,
        remove: removeNodeHook
    };
    var CommentHook = {
        create: function (vnode) {
            var owner = vnode.owner, text = vnode.text;
            var renderer = owner.renderer;
            var elm = renderer.createComment(text);
            linkNodeToShadowIfRequired(elm, owner);
            vnode.elm = elm;
        },
        update: updateNodeHook,
        insert: insertNodeHook,
        move: insertNodeHook,
        remove: removeNodeHook
    }; // insert is called after update, which is used somewhere else (via a module)
    // to mark the vm as inserted, that means we cannot use update as the main channel
    // to rehydrate when dirty, because sometimes the element is not inserted just yet,
    // which breaks some invariants. For that reason, we have the following for any
    // Custom Element that is inserted via a template.
    var ElementHook = {
        create: function (vnode) {
            var sel = vnode.sel, owner = vnode.owner, ns = vnode.data.ns;
            var renderer = owner.renderer;
            var elm = renderer.createElement(sel, ns);
            linkNodeToShadowIfRequired(elm, owner);
            fallbackElmHook(elm, vnode);
            vnode.elm = elm;
            createElmHook(vnode);
        },
        update: function (oldVnode, vnode) {
            updateElmHook(oldVnode, vnode);
            updateChildrenHook(oldVnode, vnode);
        },
        insert: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
            createChildrenHook(vnode);
        },
        move: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: function (vnode, parentNode) {
            removeNodeHook(vnode, parentNode);
            removeElmHook(vnode);
        }
    };
    var CustomElementHook = {
        create: function (vnode) {
            var sel = vnode.sel, owner = vnode.owner;
            var renderer = owner.renderer;
            var UpgradableConstructor = getUpgradableConstructor(sel, renderer);
            /**
             * Note: if the upgradable constructor does not expect, or throw when we new it
             * with a callback as the first argument, we could implement a more advanced
             * mechanism that only passes that argument if the constructor is known to be
             * an upgradable custom element.
             */
            var elm = new UpgradableConstructor(function (elm) {
                // the custom element from the registry is expecting an upgrade callback
                createViewModelHook(elm, vnode);
            });
            linkNodeToShadowIfRequired(elm, owner);
            vnode.elm = elm;
            var vm = getAssociatedVMIfPresent(elm);
            if (vm) {
                allocateChildrenHook(vnode, vm);
            }
            else if (vnode.ctor !== UpgradableConstructor) {
                throw new TypeError("Incorrect Component Constructor");
            }
            createCustomElmHook(vnode);
        },
        update: function (oldVnode, vnode) {
            updateCustomElmHook(oldVnode, vnode);
            var vm = getAssociatedVMIfPresent(vnode.elm);
            if (vm) {
                // in fallback mode, the allocation will always set children to
                // empty and delegate the real allocation to the slot elements
                allocateChildrenHook(vnode, vm);
            } // in fallback mode, the children will be always empty, so, nothing
            // will happen, but in native, it does allocate the light dom
            updateChildrenHook(oldVnode, vnode);
            if (vm) {
                // this is important to preserve the top to bottom synchronous rendering phase.
                rerenderVM(vm);
            }
        },
        insert: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
            var vm = getAssociatedVMIfPresent(vnode.elm);
            if (vm) {
                runConnectedCallback(vm);
            }
            createChildrenHook(vnode);
            if (vm) {
                appendVM(vm);
            }
        },
        move: function (vnode, parentNode, referenceNode) {
            insertNodeHook(vnode, parentNode, referenceNode);
        },
        remove: function (vnode, parentNode) {
            removeNodeHook(vnode, parentNode);
            var vm = getAssociatedVMIfPresent(vnode.elm);
            if (vm) {
                // for custom elements we don't have to go recursively because the removeVM routine
                // will take care of disconnecting any child VM attached to its shadow as well.
                removeVM(vm);
            }
        }
    };
    function linkNodeToShadowIfRequired(elm, owner) {
        var renderer = owner.renderer, cmpRoot = owner.cmpRoot; // TODO [#1164]: this should eventually be done by the polyfill directly
        if (isLightRenderModeVM(owner) && renderer.syntheticShadow) {
            elm.$shadowResolver$ = cmpRoot.$shadowResolver$;
        }
    } // TODO [#1136]: this should be done by the compiler, adding ns to every sub-element
    function addNS(vnode) {
        var data = vnode.data, children = vnode.children, sel = vnode.sel;
        data.ns = NamespaceAttributeForSVG; // TODO [#1275]: review why `sel` equal `foreignObject` should get this `ns`
        if (isArray$1(children) && sel !== 'foreignObject') {
            for (var j = 0, n = children.length; j < n; ++j) {
                var childNode = children[j];
                if (childNode != null && childNode.hook === ElementHook) {
                    addNS(childNode);
                }
            }
        }
    }
    function addVNodeToChildLWC(vnode) {
        ArrayPush$2.call(getVMBeingRendered().velements, vnode);
    } // [h]tml node
    function h(sel, data, children) {
        var vmBeingRendered = getVMBeingRendered();
        var key = data.key;
        var text, elm;
        var vnode = {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: ElementHook,
            owner: vmBeingRendered
        };
        if (sel.length === 3 && StringCharCodeAt.call(sel, 0) === CHAR_S && StringCharCodeAt.call(sel, 1) === CHAR_V && StringCharCodeAt.call(sel, 2) === CHAR_G) {
            addNS(vnode);
        }
        return vnode;
    } // [t]ab[i]ndex function
    function ti(value) {
        // if value is greater than 0, we normalize to 0
        // If value is an invalid tabIndex value (null, undefined, string, etc), we let that value pass through
        // If value is less than -1, we don't care
        var shouldNormalize = value > 0 && !(isTrue$2(value) || isFalse$2(value));
        return shouldNormalize ? 0 : value;
    } // [s]lot element node
    function s(slotName, data, children, slotset) {
        if (!isUndefined$3(slotset) && !isUndefined$3(slotset[slotName]) && slotset[slotName].length !== 0) {
            children = slotset[slotName];
        }
        var vmBeingRendered = getVMBeingRendered();
        if (!isLightRenderModeVM(vmBeingRendered)) {
            sc(children);
            return children;
        }
        if (vmBeingRendered.renderer.syntheticShadow) {
            // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
            sc(children);
        }
        return h('slot', data, children);
    } // [c]ustom element node
    function c(sel, Ctor, data, children) {
        if (children === void 0) { children = EmptyArray; }
        var vmBeingRendered = getVMBeingRendered();
        var key = data.key;
        var text, elm;
        var vnode = {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: CustomElementHook,
            ctor: Ctor,
            owner: vmBeingRendered,
            mode: 'open' // TODO [#1294]: this should be defined in Ctor
        };
        addVNodeToChildLWC(vnode);
        return vnode;
    } // [i]terable node
    function i(iterable, factory) {
        var list = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(list);
        if (isUndefined$3(iterable) || iterable === null) {
            return list;
        }
        var iterator = iterable[SymbolIterator]();
        var next = iterator.next();
        var j = 0;
        var value = next.value, last = next.done;
        while (last === false) {
            // implementing a look-back-approach because we need to know if the element is the last
            next = iterator.next();
            last = next.done; // template factory logic based on the previous collected value
            var vnode = factory(value, j, j === 0, last);
            if (isArray$1(vnode)) {
                ArrayPush$2.apply(list, vnode);
            }
            else {
                ArrayPush$2.call(list, vnode);
            }
            j += 1;
            value = next.value;
        }
        return list;
    }
    /**
     * [f]lattening
     */
    function f(items) {
        var len = items.length;
        var flattened = []; // TODO [#1276]: compiler should give us some sort of indicator when a vnodes collection is dynamic
        sc(flattened);
        for (var j = 0; j < len; j += 1) {
            var item = items[j];
            if (isArray$1(item)) {
                ArrayPush$2.apply(flattened, item);
            }
            else {
                ArrayPush$2.call(flattened, item);
            }
        }
        return flattened;
    } // [t]ext node
    function t(text) {
        var data = EmptyObject;
        var sel, children, key, elm;
        return {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: TextHook,
            owner: getVMBeingRendered()
        };
    } // [co]mment node
    function co(text) {
        var data = EmptyObject;
        var sel, children, key, elm;
        return {
            sel: sel,
            data: data,
            children: children,
            text: text,
            elm: elm,
            key: key,
            hook: CommentHook,
            owner: getVMBeingRendered()
        };
    } // [d]ynamic value to produce a text vnode
    function d(value) {
        if (value == null) {
            return null;
        }
        return t(value);
    } // [b]ind function
    function b(fn) {
        var vmBeingRendered = getVMBeingRendered();
        if (isNull(vmBeingRendered)) {
            throw new Error();
        }
        var vm = vmBeingRendered;
        return function (event) {
            invokeEventListener(vm, fn, vm.component, event);
        };
    } // [k]ey function
    function k(compilerKey, obj) {
        switch (typeof obj) {
            case 'number':
            case 'string':
                return compilerKey + ':' + obj;
        }
    } // [g]lobal [id] function
    function gid(id) {
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined$3(id) || id === '') {
            return id;
        } // We remove attributes when they are assigned a value of null
        if (isNull(id)) {
            return null;
        }
        if (isLightRenderModeVM(vmBeingRendered)) {
            return StringReplace.call(id, /\S+/g, function (id) { return id + "-" + vmBeingRendered.idx; });
        }
        return id;
    } // [f]ragment [id] function
    function fid(url) {
        var vmBeingRendered = getVMBeingRendered();
        if (isUndefined$3(url) || url === '') {
            return url;
        } // We remove attributes when they are assigned a value of null
        if (isNull(url)) {
            return null;
        } // Apply transformation only for fragment-only-urls, and only in shadow DOM
        if (/^#/.test(url) && isLightRenderModeVM(vmBeingRendered)) {
            return url + "-" + vmBeingRendered.idx;
        }
        return url;
    }
    /**
     * Map to store an index value assigned to any dynamic component reference ingested
     * by dc() api. This allows us to generate a unique unique per template per dynamic
     * component reference to avoid diffing algo mismatches.
     */
    var DynamicImportedComponentMap = new Map();
    var dynamicImportedComponentCounter = 0;
    /**
     * create a dynamic component via `<x-foo lwc:dynamic={Ctor}>`
     */
    function dc(sel, Ctor, data, children) {
        if (Ctor == null) {
            return null;
        }
        if (!isComponentConstructor(Ctor)) {
            throw new Error("Invalid LWC Constructor " + toString$1(Ctor) + " for custom element <" + sel + ">.");
        }
        var idx = DynamicImportedComponentMap.get(Ctor);
        if (isUndefined$3(idx)) {
            idx = dynamicImportedComponentCounter++;
            DynamicImportedComponentMap.set(Ctor, idx);
        } // the new vnode key is a mix of idx and compiler key, this is required by the diffing algo
        // to identify different constructors as vnodes with different keys to avoid reusing the
        // element used for previous constructors.
        data.key = "dc:" + idx + ":" + data.key;
        return c(sel, Ctor, data, children);
    }
    /**
     * slow children collection marking mechanism. this API allows the compiler to signal
     * to the engine that a particular collection of children must be diffed using the slow
     * algo based on keys due to the nature of the list. E.g.:
     *
     *   - slot element's children: the content of the slot has to be dynamic when in synthetic
     *                              shadow mode because the `vnode.children` might be the slotted
     *                              content vs default content, in which case the size and the
     *                              keys are not matching.
     *   - children that contain dynamic components
     *   - children that are produced by iteration
     *
     */
    function sc(vnodes) {
        // choose to use the snabbdom virtual dom diffing algo instead of our
        // static dummy algo.
        markAsDynamicChildren(vnodes);
        return vnodes;
    }
    var api = /*#__PURE__*/ Object.freeze({
        __proto__: null,
        h: h,
        ti: ti,
        s: s,
        c: c,
        i: i,
        f: f,
        t: t,
        co: co,
        d: d,
        b: b,
        k: k,
        gid: gid,
        fid: fid,
        dc: dc,
        sc: sc
    });
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createInlineStyleVNode(content) {
        return h('style', {
            key: 'style',
            attrs: {
                type: 'text/css'
            }
        }, [t(content)]);
    }
    function updateSyntheticShadowAttributes(vm, template) {
        var elm = vm.elm, context = vm.context, renderer = vm.renderer;
        var newStylesheets = template.stylesheets, newStylesheetTokens = template.stylesheetTokens;
        var newTokens; // Reset the styling token applied to the host element.
        var oldHostAttribute = context.hostAttribute;
        if (!isUndefined$3(oldHostAttribute)) {
            renderer.removeAttribute(elm, oldHostAttribute);
        } // Apply the new template styling token to the host element, if the new template has any
        // associated stylesheets.
        if (!isUndefined$3(newStylesheets) && newStylesheets.length !== 0 && isLightRenderModeVM(vm)) {
            newTokens = newStylesheetTokens;
        }
        if (!isUndefined$3(newTokens)) {
            renderer.setAttribute(elm, newTokens.hostAttribute, '');
        } // Update the styling tokens present on the context object.
        context.hostAttribute = newTokens === null || newTokens === void 0 ? void 0 : newTokens.hostAttribute;
        context.shadowAttribute = newTokens === null || newTokens === void 0 ? void 0 : newTokens.shadowAttribute;
    }
    function evaluateStylesheetsContent(stylesheets, hostSelector, shadowSelector, nativeShadow) {
        var content = [];
        for (var i_12 = 0; i_12 < stylesheets.length; i_12++) {
            var stylesheet = stylesheets[i_12];
            if (isArray$1(stylesheet)) {
                ArrayPush$2.apply(content, evaluateStylesheetsContent(stylesheet, hostSelector, shadowSelector, nativeShadow));
            }
            else {
                ArrayPush$2.call(content, stylesheet(hostSelector, shadowSelector, nativeShadow));
            }
        }
        return content;
    }
    function getStylesheetsContent(vm, template) {
        var stylesheets = template.stylesheets, stylesheetTokens = template.stylesheetTokens;
        var syntheticShadow = vm.renderer.syntheticShadow;
        var content = [];
        if (!isUndefined$3(stylesheets) && stylesheets.length !== 0) {
            var hostSelector = void 0;
            var shadowSelector = // Scoping with the tokens is only necessary for synthetic shadow. For both
             void 0; // Scoping with the tokens is only necessary for synthetic shadow. For both
            // light DOM elements and native shadow, we just render the CSS as-is.
            if (syntheticShadow && isLightRenderModeVM(vm) && !isUndefined$3(stylesheetTokens)) {
                hostSelector = "[" + stylesheetTokens.hostAttribute + "]";
                shadowSelector = "[" + stylesheetTokens.shadowAttribute + "]";
            }
            else {
                hostSelector = '';
                shadowSelector = '';
            }
            content = evaluateStylesheetsContent(stylesheets, hostSelector, shadowSelector, !syntheticShadow);
        }
        return content;
    }
    function createStylesheet(vm, stylesheets) {
        var renderer = vm.renderer;
        if (renderer.syntheticShadow && isLightRenderModeVM(vm)) {
            for (var i_13 = 0; i_13 < stylesheets.length; i_13++) {
                renderer.insertGlobalStylesheet(stylesheets[i_13]);
            }
            return null;
        }
        else {
            // native shadow or light DOM
            var combinedStylesheetContent = ArrayJoin.call(stylesheets, '\n');
            return createInlineStyleVNode(combinedStylesheetContent);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var GlobalMeasurementPhase;
    (function (GlobalMeasurementPhase) {
        GlobalMeasurementPhase["REHYDRATE"] = "lwc-rehydrate";
        GlobalMeasurementPhase["HYDRATE"] = "lwc-hydrate";
    })(GlobalMeasurementPhase || (GlobalMeasurementPhase = {})); // Even if all the browser the engine supports implements the UserTiming API, we need to guard the measure APIs.
    // JSDom (used in Jest) for example doesn't implement the UserTiming APIs.
    var isUserTimingSupported = typeof performance !== 'undefined' && typeof performance.mark === 'function' && typeof performance.clearMarks === 'function' && typeof performance.measure === 'function' && typeof performance.clearMeasures === 'function';
    function getMarkName(phase, vm) {
        // Adding the VM idx to the mark name creates a unique mark name component instance. This is necessary to produce
        // the right measures for components that are recursive.
        return getComponentTag(vm) + " - " + phase + " - " + vm.idx;
    }
    function getMeasureName(phase, vm) {
        return getComponentTag(vm) + " - " + phase;
    }
    function start(markName) {
        performance.mark(markName);
    }
    function end(measureName, markName) {
        performance.measure(measureName, markName); // Clear the created marks and measure to avoid filling the performance entries buffer.
        // Note: Even if the entries get deleted, existing PerformanceObservers preserve a copy of those entries.
        performance.clearMarks(markName);
        performance.clearMarks(measureName);
    }
    function noop$3() {
        /* do nothing */
    }
    var startMeasure = !isUserTimingSupported ? noop$3 : function (phase, vm) {
        var markName = getMarkName(phase, vm);
        start(markName);
    };
    var endMeasure = !isUserTimingSupported ? noop$3 : function (phase, vm) {
        var markName = getMarkName(phase, vm);
        var measureName = getMeasureName(phase, vm);
        end(measureName, markName);
    };
    var startGlobalMeasure = !isUserTimingSupported ? noop$3 : function (phase, vm) {
        var markName = isUndefined$3(vm) ? phase : getMarkName(phase, vm);
        start(markName);
    };
    var endGlobalMeasure = !isUserTimingSupported ? noop$3 : function (phase, vm) {
        var markName = isUndefined$3(vm) ? phase : getMarkName(phase, vm);
        end(phase, markName);
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function noop$2(_opId, _phase, _cmpName, _vm_idx) { }
    var logOperation = noop$2;
    var OperationId;
    (function (OperationId) {
        OperationId[OperationId["constructor"] = 0] = "constructor";
        OperationId[OperationId["render"] = 1] = "render";
        OperationId[OperationId["patch"] = 2] = "patch";
        OperationId[OperationId["connectedCallback"] = 3] = "connectedCallback";
        OperationId[OperationId["renderedCallback"] = 4] = "renderedCallback";
        OperationId[OperationId["disconnectedCallback"] = 5] = "disconnectedCallback";
        OperationId[OperationId["errorCallback"] = 6] = "errorCallback";
    })(OperationId || (OperationId = {}));
    var Phase;
    (function (Phase) {
        Phase[Phase["Start"] = 0] = "Start";
        Phase[Phase["Stop"] = 1] = "Stop";
    })(Phase || (Phase = {}));
    var opIdToMeasurementPhaseMappingArray = ['constructor', 'render', 'patch', 'connectedCallback', 'renderedCallback', 'disconnectedCallback', 'errorCallback'];
    var profilerEnabled$3 = false;
    var logMarks = false;
    var bufferLogging = false;
    var profilerStateCallbacks = [];
    function trackProfilerState(callback) {
        callback(profilerEnabled$3);
        profilerStateCallbacks.push(callback);
    }
    function logOperationStart(opId, vm) {
        if (logMarks) {
            startMeasure(opIdToMeasurementPhaseMappingArray[opId], vm);
        }
        if (bufferLogging) {
            logOperation(opId, Phase.Start, vm.tagName, vm.idx);
        }
    }
    function logOperationEnd(opId, vm) {
        if (logMarks) {
            endMeasure(opIdToMeasurementPhaseMappingArray[opId], vm);
        }
        if (bufferLogging) {
            logOperation(opId, Phase.Stop, vm.tagName, vm.idx);
        }
    }
    function enableProfiler() {
        profilerEnabled$3 = true;
        bufferLogging = true;
        notifyProfilerStateChange();
    }
    function disableProfiler() {
        {
            profilerEnabled$3 = false;
            bufferLogging = false;
            logMarks = false;
        }
        notifyProfilerStateChange();
    }
    function notifyProfilerStateChange() {
        for (var i_14 = 0; i_14 < profilerStateCallbacks.length; i_14++) {
            profilerStateCallbacks[i_14](profilerEnabled$3);
        }
    }
    function attachDispatcher(dispatcher) {
        logOperation = dispatcher;
        bufferLogging = true;
    }
    function detachDispatcher() {
        var currentLogOperation = logOperation;
        logOperation = noop$2;
        bufferLogging = false;
        return currentLogOperation;
    }
    var profilerControl = {
        enableProfiler: enableProfiler,
        disableProfiler: disableProfiler,
        attachDispatcher: attachDispatcher,
        detachDispatcher: detachDispatcher
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var isUpdatingTemplate = false;
    var vmBeingRendered = null;
    function getVMBeingRendered() {
        return vmBeingRendered;
    }
    function setVMBeingRendered(vm) {
        vmBeingRendered = vm;
    }
    var profilerEnabled$2 = false;
    trackProfilerState(function (t) { return profilerEnabled$2 = t; });
    function validateSlots(vm, html) {
        {
            // this method should never leak to prod
            throw new ReferenceError();
        }
    }
    function validateLightDomTemplate(template, vm) {
        if (template === defaultEmptyTemplate)
            return;
        if (!isLightRenderModeVM(vm)) {
            assert.isTrue(template.renderMode === 'light', "Light DOM components can't render shadow DOM templates. Add an 'lwc:render-mode=\"light\"' directive on the root template tag.");
        }
        else {
            assert.isTrue(isUndefined$3(template.renderMode), "Shadow DOM components template can't render light DOM templates. Either remove the 'lwc:render-mode' directive or set it to 'lwc:render-mode=\"shadow\"");
        }
    }
    function evaluateTemplate(vm, html) {
        var isUpdatingTemplateInception = isUpdatingTemplate;
        var vmOfTemplateBeingUpdatedInception = vmBeingRendered;
        var vnodes = [];
        runWithBoundaryProtection(vm, vm.owner, function () {
            // pre
            vmBeingRendered = vm;
            if (profilerEnabled$2) {
                logOperationStart(OperationId.render, vm);
            }
        }, function () {
            // job
            var component = vm.component, context = vm.context, cmpSlots = vm.cmpSlots, cmpTemplate = vm.cmpTemplate, tro = vm.tro, renderer = vm.renderer;
            tro.observe(function () {
                // Reset the cache memoizer for template when needed.
                if (html !== cmpTemplate) {
                    if ("production" !== 'production') ; // Perf opt: do not reset the shadow root during the first rendering (there is
                    // nothing to reset).
                    if (!isNull(cmpTemplate)) {
                        // It is important to reset the content to avoid reusing similar elements
                        // generated from a different template, because they could have similar IDs,
                        // and snabbdom just rely on the IDs.
                        resetComponentRoot(vm);
                    } // Check that the template was built by the compiler.
                    if (!isTemplateRegistered(html)) {
                        throw new TypeError("Invalid template returned by the render() method on " + vm + ". It must return an imported template (e.g.: `import html from \"./" + vm.def.name + ".html\"`), instead, it has returned: " + toString$1(html) + ".");
                    }
                    vm.cmpTemplate = html; // Create a brand new template cache for the swapped templated.
                    context.tplCache = create$2(null); // Update the synthetic shadow attributes on the host element if necessary.
                    if (renderer.syntheticShadow) {
                        updateSyntheticShadowAttributes(vm, html);
                    } // Evaluate, create stylesheet and cache the produced VNode for future
                    // re-rendering.
                    var stylesheetsContent = getStylesheetsContent(vm, html);
                    context.styleVNode = stylesheetsContent.length === 0 ? null : createStylesheet(vm, stylesheetsContent);
                }
                if ("production" !== 'production') ; // right before producing the vnodes, we clear up all internal references
                // to custom elements from the template.
                vm.velements = []; // Set the global flag that template is being updated
                isUpdatingTemplate = true;
                vnodes = html.call(undefined, api, component, cmpSlots, context.tplCache);
                var styleVNode = context.styleVNode;
                if (!isNull(styleVNode)) {
                    ArrayUnshift.call(vnodes, styleVNode);
                }
            });
        }, function () {
            // post
            isUpdatingTemplate = isUpdatingTemplateInception;
            vmBeingRendered = vmOfTemplateBeingUpdatedInception;
            if (profilerEnabled$2) {
                logOperationEnd(OperationId.render, vm);
            }
        });
        return vnodes;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function addErrorComponentStack(vm, error) {
        if (!isFrozen$1(error) && isUndefined$3(error.wcStack)) {
            var wcStack_1 = getErrorComponentStack(vm);
            defineProperty$1(error, 'wcStack', {
                get: function () {
                    return wcStack_1;
                }
            });
        }
    }
    var vmBeingConstructed = null;
    function isBeingConstructed(vm) {
        return vmBeingConstructed === vm;
    }
    var profilerEnabled$1 = false;
    trackProfilerState(function (t) { return profilerEnabled$1 = t; });
    var noop$1 = function () { return void 0; };
    function invokeComponentCallback(vm, fn, args) {
        var component = vm.component, callHook = vm.callHook, owner = vm.owner;
        var result;
        runWithBoundaryProtection(vm, owner, noop$1, function () {
            // job
            result = callHook(component, fn, args);
        }, noop$1);
        return result;
    }
    function invokeComponentConstructor(vm, Ctor) {
        var vmBeingConstructedInception = vmBeingConstructed;
        var error;
        if (profilerEnabled$1) {
            logOperationStart(OperationId.constructor, vm);
        }
        vmBeingConstructed = vm;
        /**
         * Constructors don't need to be wrapped with a boundary because for root elements
         * it should throw, while elements from template are already wrapped by a boundary
         * associated to the diffing algo.
         */
        try {
            // job
            var result = new Ctor(); // Check indirectly if the constructor result is an instance of LightningElement. Using
            // the "instanceof" operator would not work here since Locker Service provides its own
            // implementation of LightningElement, so we indirectly check if the base constructor is
            // invoked by accessing the component on the vm.
            if (vmBeingConstructed.component !== result) {
                throw new TypeError('Invalid component constructor, the class should extend LightningElement.');
            }
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            if (profilerEnabled$1) {
                logOperationEnd(OperationId.constructor, vm);
            }
            vmBeingConstructed = vmBeingConstructedInception;
            if (!isUndefined$3(error)) {
                addErrorComponentStack(vm, error); // re-throwing the original error annotated after restoring the context
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
    }
    function invokeComponentRenderMethod(vm) {
        var render = vm.def.render, callHook = vm.callHook, component = vm.component, owner = vm.owner;
        var vmBeingRenderedInception = getVMBeingRendered();
        var html;
        var renderInvocationSuccessful = false;
        runWithBoundaryProtection(vm, owner, function () {
            setVMBeingRendered(vm);
        }, function () {
            // job
            vm.tro.observe(function () {
                html = callHook(component, render);
                renderInvocationSuccessful = true;
            });
        }, function () {
            setVMBeingRendered(vmBeingRenderedInception);
        }); // If render() invocation failed, process errorCallback in boundary and return an empty template
        return renderInvocationSuccessful ? evaluateTemplate(vm, html) : [];
    }
    function invokeComponentRenderedCallback(vm) {
        var renderedCallback = vm.def.renderedCallback, component = vm.component, callHook = vm.callHook, owner = vm.owner;
        if (!isUndefined$3(renderedCallback)) {
            runWithBoundaryProtection(vm, owner, function () {
                if (profilerEnabled$1) {
                    logOperationStart(OperationId.renderedCallback, vm);
                }
            }, function () {
                // job
                callHook(component, renderedCallback);
            }, function () {
                // post
                if (profilerEnabled$1) {
                    logOperationEnd(OperationId.renderedCallback, vm);
                }
            });
        }
    }
    function invokeEventListener(vm, fn, thisValue, event) {
        var callHook = vm.callHook, owner = vm.owner;
        runWithBoundaryProtection(vm, owner, noop$1, function () {
            // job
            if ("production" !== 'production') ;
            callHook(thisValue, fn, [event]);
        }, noop$1);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var signedTemplateMap = new Map();
    /**
     * INTERNAL: This function can only be invoked by compiled code. The compiler
     * will prevent this function from being imported by userland code.
     */
    function registerComponent(Ctor, _b) {
        var tmpl = _b.tmpl;
        signedTemplateMap.set(Ctor, tmpl); // chaining this method as a way to wrap existing assignment of component constructor easily,
        // without too much transformation
        return Ctor;
    }
    function getComponentRegisteredTemplate(Ctor) {
        return signedTemplateMap.get(Ctor);
    }
    function createComponent(vm, Ctor) {
        // create the component instance
        invokeComponentConstructor(vm, Ctor);
        if (isUndefined$3(vm.component)) {
            throw new ReferenceError("Invalid construction for " + Ctor + ", you must extend LightningElement.");
        }
    }
    function getTemplateReactiveObserver(vm) {
        return new ReactiveObserver(function () {
            var isDirty = vm.isDirty;
            if (isFalse$2(isDirty)) {
                markComponentAsDirty(vm);
                scheduleRehydration(vm);
            }
        });
    }
    function renderComponent(vm) {
        vm.tro.reset();
        var vnodes = invokeComponentRenderMethod(vm);
        vm.isDirty = false;
        vm.isScheduled = false;
        return vnodes;
    }
    function markComponentAsDirty(vm) {
        vm.isDirty = true;
    }
    var cmpEventListenerMap = new WeakMap();
    function getWrappedComponentsListener(vm, listener) {
        if (!isFunction$1(listener)) {
            throw new TypeError(); // avoiding problems with non-valid listeners
        }
        var wrappedListener = cmpEventListenerMap.get(listener);
        if (isUndefined$3(wrappedListener)) {
            wrappedListener = function (event) {
                invokeEventListener(vm, listener, undefined, event);
            };
            cmpEventListenerMap.set(listener, wrappedListener);
        }
        return wrappedListener;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var Services = create$2(null);
    var hooks = ['rendered', 'connected', 'disconnected'];
    /**
     * EXPERIMENTAL: This function allows for the registration of "services"
     * in LWC by exposing hooks into the component life-cycle. This API is
     * subject to change or being removed.
     */
    function register(service) {
        for (var i_15 = 0; i_15 < hooks.length; ++i_15) {
            var hookName = hooks[i_15];
            if (hookName in service) {
                var l = Services[hookName];
                if (isUndefined$3(l)) {
                    Services[hookName] = l = [];
                }
                ArrayPush$2.call(l, service[hookName]);
            }
        }
    }
    function invokeServiceHook(vm, cbs) {
        var component = vm.component, def = vm.def, context = vm.context;
        for (var i_16 = 0, len = cbs.length; i_16 < len; ++i_16) {
            cbs[i_16].call(undefined, component, {}, def, context);
        }
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var VMState;
    (function (VMState) {
        VMState[VMState["created"] = 0] = "created";
        VMState[VMState["connected"] = 1] = "connected";
        VMState[VMState["disconnected"] = 2] = "disconnected";
    })(VMState || (VMState = {}));
    var profilerEnabled = false;
    trackProfilerState(function (t) { return profilerEnabled = t; });
    var idx = 0;
    /** The internal slot used to associate different objects the engine manipulates with the VM */
    var ViewModelReflection = createHiddenField('ViewModel', 'engine');
    function callHook(cmp, fn, args) {
        if (args === void 0) { args = []; }
        return fn.apply(cmp, args);
    }
    function setHook(cmp, prop, newValue) {
        cmp[prop] = newValue;
    }
    function getHook(cmp, prop) {
        return cmp[prop];
    }
    function rerenderVM(vm) {
        rehydrate(vm);
    }
    function connectRootElement(elm) {
        var vm = getAssociatedVM(elm);
        startGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm); // Usually means moving the element from one place to another, which is observable via
        // life-cycle hooks.
        if (vm.state === VMState.connected) {
            disconnectRootElement(elm);
        }
        runConnectedCallback(vm);
        rehydrate(vm);
        endGlobalMeasure(GlobalMeasurementPhase.HYDRATE, vm);
    }
    function disconnectRootElement(elm) {
        var vm = getAssociatedVM(elm);
        resetComponentStateWhenRemoved(vm);
    }
    function appendVM(vm) {
        rehydrate(vm);
    } // just in case the component comes back, with this we guarantee re-rendering it
    // while preventing any attempt to rehydration until after reinsertion.
    function resetComponentStateWhenRemoved(vm) {
        var state = vm.state;
        if (state !== VMState.disconnected) {
            var oar = vm.oar, tro = vm.tro; // Making sure that any observing record will not trigger the rehydrated on this vm
            tro.reset(); // Making sure that any observing accessor record will not trigger the setter to be reinvoked
            for (var key in oar) {
                oar[key].reset();
            }
            runDisconnectedCallback(vm); // Spec: https://dom.spec.whatwg.org/#concept-node-remove (step 14-15)
            runChildNodesDisconnectedCallback(vm);
            runLightChildNodesDisconnectedCallback(vm);
        }
    } // this method is triggered by the diffing algo only when a vnode from the
    // old vnode.children is removed from the DOM.
    function removeVM(vm) {
        resetComponentStateWhenRemoved(vm);
    }
    function createVM(elm, def, options) {
        var mode = options.mode, owner = options.owner, renderer = options.renderer, tagName = options.tagName;
        var vm = {
            elm: elm,
            def: def,
            idx: idx++,
            state: VMState.created,
            isScheduled: false,
            isDirty: true,
            tagName: tagName,
            mode: mode,
            owner: owner,
            renderer: renderer,
            children: EmptyArray,
            aChildren: EmptyArray,
            velements: EmptyArray,
            cmpProps: create$2(null),
            cmpFields: create$2(null),
            cmpSlots: create$2(null),
            oar: create$2(null),
            cmpTemplate: null,
            context: {
                hostAttribute: undefined,
                shadowAttribute: undefined,
                styleVNode: null,
                tplCache: EmptyObject,
                wiredConnecting: EmptyArray,
                wiredDisconnecting: EmptyArray
            },
            tro: null,
            component: null,
            cmpRoot: null,
            callHook: callHook,
            setHook: setHook,
            getHook: getHook
        };
        vm.tro = getTemplateReactiveObserver(vm);
        createComponent(vm, def.ctor); // Initializing the wire decorator per instance only when really needed
        if (isFalse$2(renderer.ssr) && hasWireAdapters(vm)) {
            installWireAdapters(vm);
        }
        return vm;
    }
    function associateVM(obj, vm) {
        setHiddenField(obj, ViewModelReflection, vm);
    }
    function getAssociatedVM(obj) {
        var vm = getHiddenField(obj, ViewModelReflection);
        return vm;
    }
    function getAssociatedVMIfPresent(obj) {
        var maybeVm = getHiddenField(obj, ViewModelReflection);
        return maybeVm;
    }
    function rehydrate(vm) {
        if (isTrue$2(vm.isDirty)) {
            var children = renderComponent(vm);
            patchShadowRoot(vm, children);
        }
    }
    function patchShadowRoot(vm, newCh) {
        var oldCh = vm.children; // caching the new children collection
        vm.children = newCh;
        if (newCh.length > 0 || oldCh.length > 0) {
            // patch function mutates vnodes by adding the element reference,
            // however, if patching fails it contains partial changes.
            if (oldCh !== newCh) {
                var fn_1 = hasDynamicChildren(newCh) ? updateDynamicChildren : updateStaticChildren;
                runWithBoundaryProtection(vm, vm, function () {
                    // pre
                    if (profilerEnabled) {
                        logOperationStart(OperationId.patch, vm);
                    }
                }, function () {
                    // job
                    var elementToRenderTo = getRenderRoot(vm);
                    fn_1(elementToRenderTo, oldCh, newCh);
                }, function () {
                    // post
                    if (profilerEnabled) {
                        logOperationEnd(OperationId.patch, vm);
                    }
                });
            }
        }
        if (vm.state === VMState.connected) {
            // If the element is connected, that means connectedCallback was already issued, and
            // any successive rendering should finish with the call to renderedCallback, otherwise
            // the connectedCallback will take care of calling it in the right order at the end of
            // the current rehydration process.
            runRenderedCallback(vm);
        }
    }
    function runRenderedCallback(vm) {
        if (isTrue$2(vm.renderer.ssr)) {
            return;
        }
        var rendered = Services.rendered;
        if (rendered) {
            invokeServiceHook(vm, rendered);
        }
        invokeComponentRenderedCallback(vm);
    }
    var rehydrateQueue = [];
    function flushRehydrationQueue() {
        startGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
        var vms = rehydrateQueue.sort(function (a, b) { return a.idx - b.idx; });
        rehydrateQueue = []; // reset to a new queue
        for (var i_17 = 0, len = vms.length; i_17 < len; i_17 += 1) {
            var vm = vms[i_17];
            try {
                rehydrate(vm);
            }
            catch (error) {
                if (i_17 + 1 < len) {
                    // pieces of the queue are still pending to be rehydrated, those should have priority
                    if (rehydrateQueue.length === 0) {
                        addCallbackToNextTick(flushRehydrationQueue);
                    }
                    ArrayUnshift.apply(rehydrateQueue, ArraySlice.call(vms, i_17 + 1));
                } // we need to end the measure before throwing.
                endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE); // re-throwing the original error will break the current tick, but since the next tick is
                // already scheduled, it should continue patching the rest.
                throw error; // eslint-disable-line no-unsafe-finally
            }
        }
        endGlobalMeasure(GlobalMeasurementPhase.REHYDRATE);
    }
    function runConnectedCallback(vm) {
        var state = vm.state;
        if (state === VMState.connected) {
            return; // nothing to do since it was already connected
        }
        vm.state = VMState.connected; // reporting connection
        var connected = Services.connected;
        if (connected) {
            invokeServiceHook(vm, connected);
        }
        if (hasWireAdapters(vm)) {
            connectWireAdapters(vm);
        }
        var connectedCallback = vm.def.connectedCallback;
        if (!isUndefined$3(connectedCallback)) {
            if (profilerEnabled) {
                logOperationStart(OperationId.connectedCallback, vm);
            }
            invokeComponentCallback(vm, connectedCallback);
            if (profilerEnabled) {
                logOperationEnd(OperationId.connectedCallback, vm);
            }
        }
    }
    function hasWireAdapters(vm) {
        return getOwnPropertyNames$2(vm.def.wire).length > 0;
    }
    function runDisconnectedCallback(vm) {
        if (isFalse$2(vm.isDirty)) {
            // this guarantees that if the component is reused/reinserted,
            // it will be re-rendered because we are disconnecting the reactivity
            // linking, so mutations are not automatically reflected on the state
            // of disconnected components.
            vm.isDirty = true;
        }
        vm.state = VMState.disconnected; // reporting disconnection
        var disconnected = Services.disconnected;
        if (disconnected) {
            invokeServiceHook(vm, disconnected);
        }
        if (hasWireAdapters(vm)) {
            disconnectWireAdapters(vm);
        }
        var disconnectedCallback = vm.def.disconnectedCallback;
        if (!isUndefined$3(disconnectedCallback)) {
            if (profilerEnabled) {
                logOperationStart(OperationId.disconnectedCallback, vm);
            }
            invokeComponentCallback(vm, disconnectedCallback);
            if (profilerEnabled) {
                logOperationEnd(OperationId.disconnectedCallback, vm);
            }
        }
    }
    function runChildNodesDisconnectedCallback(vm) {
        var vCustomElementCollection = vm.velements; // Reporting disconnection for every child in inverse order since they are
        // inserted in reserved order.
        for (var i_18 = vCustomElementCollection.length - 1; i_18 >= 0; i_18 -= 1) {
            var elm = vCustomElementCollection[i_18].elm; // There are two cases where the element could be undefined:
            // * when there is an error during the construction phase, and an error
            //   boundary picks it, there is a possibility that the VCustomElement
            //   is not properly initialized, and therefore is should be ignored.
            // * when slotted custom element is not used by the element where it is
            //   slotted into it, as  a result, the custom element was never
            //   initialized.
            if (!isUndefined$3(elm)) {
                var childVM = getAssociatedVMIfPresent(elm); // The VM associated with the element might be associated undefined
                // in the case where the VM failed in the middle of its creation,
                // eg: constructor throwing before invoking super().
                if (!isUndefined$3(childVM)) {
                    resetComponentStateWhenRemoved(childVM);
                }
            }
        }
    }
    function runLightChildNodesDisconnectedCallback(vm) {
        var adoptedChildren = vm.aChildren;
        recursivelyDisconnectChildren(adoptedChildren);
    }
    /**
     * The recursion doesn't need to be a complete traversal of the vnode graph,
     * instead it can be partial, when a custom element vnode is found, we don't
     * need to continue into its children because by attempting to disconnect the
     * custom element itself will trigger the removal of anything slotted or anything
     * defined on its shadow.
     */
    function recursivelyDisconnectChildren(vnodes) {
        for (var i_19 = 0, len = vnodes.length; i_19 < len; i_19 += 1) {
            var vnode = vnodes[i_19];
            if (!isNull(vnode) && isArray$1(vnode.children) && !isUndefined$3(vnode.elm)) {
                // vnode is a VElement with children
                if (isUndefined$3(vnode.ctor)) {
                    // it is a VElement, just keep looking (recursively)
                    recursivelyDisconnectChildren(vnode.children);
                }
                else {
                    // it is a VCustomElement, disconnect it and ignore its children
                    resetComponentStateWhenRemoved(getAssociatedVM(vnode.elm));
                }
            }
        }
    } // This is a super optimized mechanism to remove the content of the root node (shadow root
    // for shadow DOM components and the root element itself for light DOM) without having to go
    // into snabbdom. Especially useful when the reset is a consequence of an error, in which case the
    // children VNodes might not be representing the current state of the DOM.
    function resetComponentRoot(vm) {
        var children = vm.children, renderer = vm.renderer;
        var rootNode = getRenderRoot(vm);
        for (var i_20 = 0, len = children.length; i_20 < len; i_20++) {
            var child = children[i_20];
            if (!isNull(child) && !isUndefined$3(child.elm)) {
                renderer.remove(child.elm, rootNode);
            }
        }
        vm.children = EmptyArray;
        runChildNodesDisconnectedCallback(vm);
        vm.velements = EmptyArray;
    }
    function scheduleRehydration(vm) {
        if (isTrue$2(vm.renderer.ssr) || isTrue$2(vm.isScheduled)) {
            return;
        }
        vm.isScheduled = true;
        if (rehydrateQueue.length === 0) {
            addCallbackToNextTick(flushRehydrationQueue);
        }
        ArrayPush$2.call(rehydrateQueue, vm);
    }
    function getErrorBoundaryVM(vm) {
        var currentVm = vm;
        while (!isNull(currentVm)) {
            if (!isUndefined$3(currentVm.def.errorCallback)) {
                return currentVm;
            }
            currentVm = currentVm.owner;
        }
    } // slow path routine
    // NOTE: we should probably more this routine to the synthetic shadow folder
    // and get the allocation to be cached by in the elm instead of in the VM
    function allocateInSlot(vm, children) {
        var oldSlots = vm.cmpSlots;
        var cmpSlots = vm.cmpSlots = create$2(null);
        for (var i_21 = 0, len = children.length; i_21 < len; i_21 += 1) {
            var vnode = children[i_21];
            if (isNull(vnode)) {
                continue;
            }
            var data = vnode.data;
            var slotName = data.attrs && data.attrs.slot || '';
            var vnodes = cmpSlots[slotName] = cmpSlots[slotName] || []; // re-keying the vnodes is necessary to avoid conflicts with default content for the slot
            // which might have similar keys. Each vnode will always have a key that
            // starts with a numeric character from compiler. In this case, we add a unique
            // notation for slotted vnodes keys, e.g.: `@foo:1:1`
            if (!isUndefined$3(vnode.key)) {
                vnode.key = "@" + slotName + ":" + vnode.key;
            }
            ArrayPush$2.call(vnodes, vnode);
        }
        if (isFalse$2(vm.isDirty)) {
            // We need to determine if the old allocation is really different from the new one
            // and mark the vm as dirty
            var oldKeys = keys$1(oldSlots);
            if (oldKeys.length !== keys$1(cmpSlots).length) {
                markComponentAsDirty(vm);
                return;
            }
            for (var i_22 = 0, len = oldKeys.length; i_22 < len; i_22 += 1) {
                var key = oldKeys[i_22];
                if (isUndefined$3(cmpSlots[key]) || oldSlots[key].length !== cmpSlots[key].length) {
                    markComponentAsDirty(vm);
                    return;
                }
                var oldVNodes = oldSlots[key];
                var vnodes = cmpSlots[key];
                for (var j = 0, a = cmpSlots[key].length; j < a; j += 1) {
                    if (oldVNodes[j] !== vnodes[j]) {
                        markComponentAsDirty(vm);
                        return;
                    }
                }
            }
        }
    }
    function runWithBoundaryProtection(vm, owner, pre, job, post) {
        var error;
        pre();
        try {
            job();
        }
        catch (e) {
            error = Object(e);
        }
        finally {
            post();
            if (!isUndefined$3(error)) {
                addErrorComponentStack(vm, error);
                var errorBoundaryVm = isNull(owner) ? undefined : getErrorBoundaryVM(owner);
                if (isUndefined$3(errorBoundaryVm)) {
                    throw error; // eslint-disable-line no-unsafe-finally
                }
                resetComponentRoot(vm); // remove offenders
                if (profilerEnabled) {
                    logOperationStart(OperationId.errorCallback, vm);
                } // error boundaries must have an ErrorCallback
                var errorCallback = errorBoundaryVm.def.errorCallback;
                invokeComponentCallback(errorBoundaryVm, errorCallback, [error, error.wcStack]);
                if (profilerEnabled) {
                    logOperationEnd(OperationId.errorCallback, vm);
                }
            }
        }
    }
    function isLightRenderModeVM(vm) {
        // We don't refer to vm.def.ctor.shadow because that could be changed by user
        // after instantiation.
        return !isNull(vm.cmpRoot);
    }
    function getRenderRoot(vm) {
        return isLightRenderModeVM(vm) ? vm.cmpRoot : vm.elm;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var DeprecatedWiredElementHost = '$$DeprecatedWiredElementHostKey$$';
    var DeprecatedWiredParamsMeta = '$$DeprecatedWiredParamsMetaKey$$';
    var WireMetaMap = new Map();
    function noop() { }
    var WireContextRegistrationEvent = /** @class */ (function (_super) {
        __extends(WireContextRegistrationEvent, _super);
        function WireContextRegistrationEvent(adapterToken, _b) {
            var setNewContext = _b.setNewContext, setDisconnectedCallback = _b.setDisconnectedCallback;
            var _this = _super.call(this, adapterToken, {
                bubbles: true,
                composed: true
            }) || this;
            defineProperties$1(_this, {
                setNewContext: {
                    value: setNewContext
                },
                setDisconnectedCallback: {
                    value: setDisconnectedCallback
                }
            });
            return _this;
        }
        return WireContextRegistrationEvent;
    }(CustomEvent));
    function createFieldDataCallback(vm, name) {
        var cmpFields = vm.cmpFields;
        return function (value) {
            if (value !== vm.cmpFields[name]) {
                // storing the value in the underlying storage
                cmpFields[name] = value;
                componentValueMutated(vm, name);
            }
        };
    }
    function createMethodDataCallback(vm, method) {
        return function (value) {
            // dispatching new value into the wired method
            runWithBoundaryProtection(vm, vm.owner, noop, function () {
                // job
                method.call(vm.component, value);
            }, noop);
        };
    }
    function createConfigWatcher(component, configCallback, callbackWhenConfigIsReady) {
        var hasPendingConfig = false; // creating the reactive observer for reactive params when needed
        var ro = new ReactiveObserver(function () {
            if (hasPendingConfig === false) {
                hasPendingConfig = true; // collect new config in the micro-task
                Promise.resolve().then(function () {
                    hasPendingConfig = false; // resetting current reactive params
                    ro.reset(); // dispatching a new config due to a change in the configuration
                    computeConfigAndUpdate();
                });
            }
        });
        var computeConfigAndUpdate = function () {
            var config;
            ro.observe(function () { return config = configCallback(component); }); // eslint-disable-next-line lwc-internal/no-invalid-todo
            // TODO: dev-mode validation of config based on the adapter.configSchema
            // @ts-ignore it is assigned in the observe() callback
            callbackWhenConfigIsReady(config);
        };
        return {
            computeConfigAndUpdate: computeConfigAndUpdate,
            ro: ro
        };
    }
    function createContextWatcher(vm, wireDef, callbackWhenContextIsReady) {
        var adapter = wireDef.adapter;
        var adapterContextToken = getAdapterToken(adapter);
        if (isUndefined$3(adapterContextToken)) {
            return; // no provider found, nothing to be done
        }
        var elm = vm.elm, renderer = vm.renderer, _b = vm.context, wiredConnecting = _b.wiredConnecting, wiredDisconnecting = _b.wiredDisconnecting; // waiting for the component to be connected to formally request the context via the token
        ArrayPush$2.call(wiredConnecting, function () {
            // This event is responsible for connecting the host element with another
            // element in the composed path that is providing contextual data. The provider
            // must be listening for a special dom event with the name corresponding to the value of
            // `adapterContextToken`, which will remain secret and internal to this file only to
            // guarantee that the linkage can be forged.
            var contextRegistrationEvent = new WireContextRegistrationEvent(adapterContextToken, {
                setNewContext: function (newContext) {
                    // eslint-disable-next-line lwc-internal/no-invalid-todo
                    // TODO: dev-mode validation of config based on the adapter.contextSchema
                    callbackWhenContextIsReady(newContext);
                },
                setDisconnectedCallback: function (disconnectCallback) {
                    // adds this callback into the disconnect bucket so it gets disconnected from parent
                    // the the element hosting the wire is disconnected
                    ArrayPush$2.call(wiredDisconnecting, disconnectCallback);
                }
            });
            renderer.dispatchEvent(elm, contextRegistrationEvent);
        });
    }
    function createConnector(vm, name, wireDef) {
        var method = wireDef.method, adapter = wireDef.adapter, configCallback = wireDef.configCallback, dynamic = wireDef.dynamic;
        var dataCallback = isUndefined$3(method) ? createFieldDataCallback(vm, name) : createMethodDataCallback(vm, method);
        var context;
        var connector; // Workaround to pass the component element associated to this wire adapter instance.
        defineProperty$1(dataCallback, DeprecatedWiredElementHost, {
            value: vm.elm
        });
        defineProperty$1(dataCallback, DeprecatedWiredParamsMeta, {
            value: dynamic
        });
        runWithBoundaryProtection(vm, vm, noop, function () {
            // job
            connector = new adapter(dataCallback);
        }, noop);
        var updateConnectorConfig = function (config) {
            // every time the config is recomputed due to tracking,
            // this callback will be invoked with the new computed config
            runWithBoundaryProtection(vm, vm, noop, function () {
                // job
                connector.update(config, context);
            }, noop);
        }; // Computes the current wire config and calls the update method on the wire adapter.
        // If it has params, we will need to observe changes in the next tick.
        var _b = createConfigWatcher(vm.component, configCallback, updateConnectorConfig), computeConfigAndUpdate = _b.computeConfigAndUpdate, ro = _b.ro; // if the adapter needs contextualization, we need to watch for new context and push it alongside the config
        if (!isUndefined$3(adapter.contextSchema)) {
            createContextWatcher(vm, wireDef, function (newContext) {
                // every time the context is pushed into this component,
                // this callback will be invoked with the new computed context
                if (context !== newContext) {
                    context = newContext; // Note: when new context arrives, the config will be recomputed and pushed along side the new
                    // context, this is to preserve the identity characteristics, config should not have identity
                    // (ever), while context can have identity
                    if (vm.state === VMState.connected) {
                        computeConfigAndUpdate();
                    }
                }
            });
        }
        return {
            // @ts-ignore the boundary protection executes sync, connector is always defined
            connector: connector,
            computeConfigAndUpdate: computeConfigAndUpdate,
            resetConfigWatcher: function () { return ro.reset(); }
        };
    }
    var AdapterToTokenMap = new Map();
    function getAdapterToken(adapter) {
        return AdapterToTokenMap.get(adapter);
    }
    function setAdapterToken(adapter, token) {
        AdapterToTokenMap.set(adapter, token);
    }
    function storeWiredMethodMeta(descriptor, adapter, configCallback, dynamic) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        var method = descriptor.value;
        var def = {
            adapter: adapter,
            method: method,
            configCallback: configCallback,
            dynamic: dynamic
        };
        WireMetaMap.set(descriptor, def);
    }
    function storeWiredFieldMeta(descriptor, adapter, configCallback, dynamic) {
        // support for callable adapters
        if (adapter.adapter) {
            adapter = adapter.adapter;
        }
        var def = {
            adapter: adapter,
            configCallback: configCallback,
            dynamic: dynamic
        };
        WireMetaMap.set(descriptor, def);
    }
    function installWireAdapters(vm) {
        var context = vm.context, wire = vm.def.wire;
        var wiredConnecting = context.wiredConnecting = [];
        var wiredDisconnecting = context.wiredDisconnecting = [];
        var _loop_1 = function (fieldNameOrMethod) {
            var descriptor = wire[fieldNameOrMethod];
            var wireDef = WireMetaMap.get(descriptor);
            if (!isUndefined$3(wireDef)) {
                var _b = createConnector(vm, fieldNameOrMethod, wireDef), connector_1 = _b.connector, computeConfigAndUpdate_1 = _b.computeConfigAndUpdate, resetConfigWatcher_1 = _b.resetConfigWatcher;
                var hasDynamicParams_1 = wireDef.dynamic.length > 0;
                ArrayPush$2.call(wiredConnecting, function () {
                    connector_1.connect();
                    if (hasDynamicParams_1) {
                        Promise.resolve().then(computeConfigAndUpdate_1);
                    }
                    else {
                        computeConfigAndUpdate_1();
                    }
                });
                ArrayPush$2.call(wiredDisconnecting, function () {
                    connector_1.disconnect();
                    resetConfigWatcher_1();
                });
            }
        };
        for (var fieldNameOrMethod in wire) {
            _loop_1(fieldNameOrMethod);
        }
    }
    function connectWireAdapters(vm) {
        var wiredConnecting = vm.context.wiredConnecting;
        for (var i_23 = 0, len = wiredConnecting.length; i_23 < len; i_23 += 1) {
            wiredConnecting[i_23]();
        }
    }
    function disconnectWireAdapters(vm) {
        var wiredDisconnecting = vm.context.wiredDisconnecting;
        runWithBoundaryProtection(vm, vm, noop, function () {
            // job
            for (var i_24 = 0, len = wiredDisconnecting.length; i_24 < len; i_24 += 1) {
                wiredDisconnecting[i_24]();
            }
        }, noop);
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    function createContextProvider(adapter) {
        var adapterContextToken = getAdapterToken(adapter);
        if (!isUndefined$3(adapterContextToken)) {
            throw new Error("Adapter already has a context provider.");
        }
        adapterContextToken = guid();
        setAdapterToken(adapter, adapterContextToken);
        var providers = new WeakSet();
        return function (elm, options) {
            if (providers.has(elm)) {
                throw new Error("Adapter was already installed on " + elm + ".");
            }
            providers.add(elm);
            var consumerConnectedCallback = options.consumerConnectedCallback, consumerDisconnectedCallback = options.consumerDisconnectedCallback;
            elm.addEventListener(adapterContextToken, function (evt) {
                var setNewContext = evt.setNewContext, setDisconnectedCallback = evt.setDisconnectedCallback;
                var consumer = {
                    provide: function (newContext) {
                        setNewContext(newContext);
                    }
                };
                var disconnectCallback = function () {
                    if (!isUndefined$3(consumerDisconnectedCallback)) {
                        consumerDisconnectedCallback(consumer);
                    }
                };
                setDisconnectedCallback(disconnectCallback);
                consumerConnectedCallback(consumer);
                evt.stopImmediatePropagation();
            });
        };
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function allows you to create a reactive readonly
     * membrane around any object value. This API is subject to change or
     * being removed.
     */
    function readonly(obj) {
        return reactiveMembrane.getReadOnlyProxy(obj);
    }
    /* version: 2.1.2 */
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var globalStylesheets = create$3(null);
    var globalStylesheetsParentElement = document.head || document.body || document;
    var getCustomElement, defineCustomElement, HTMLElementConstructor;
    function isCustomElementRegistryAvailable() {
        if (typeof customElements === 'undefined') {
            return false;
        }
        try {
            // dereference HTMLElement global because babel wraps globals in compat mode with a
            // _wrapNativeSuper()
            // This is a problem because LWCUpgradableElement extends renderer.HTMLElement which does not
            // get wrapped by babel.
            var HTMLElementAlias = HTMLElement; // In case we use compat mode with a modern browser, the compat mode transformation
            // invokes the DOM api with an .apply() or .call() to initialize any DOM api sub-classing,
            // which are not equipped to be initialized that way.
            var clazz = /** @class */ (function (_super) {
                __extends(clazz, _super);
                function clazz() {
                    return _super !== null && _super.apply(this, arguments) || this;
                }
                return clazz;
            }(HTMLElementAlias));
            customElements.define('lwc-test-' + Math.floor(Math.random() * 1000000), clazz);
            new clazz();
            return true;
        }
        catch (_a) {
            return false;
        }
    }
    if (isCustomElementRegistryAvailable()) {
        getCustomElement = customElements.get.bind(customElements);
        defineCustomElement = customElements.define.bind(customElements);
        HTMLElementConstructor = HTMLElement;
    }
    else {
        var registry_1 = create$3(null);
        var reverseRegistry_1 = new WeakMap();
        defineCustomElement = function define(name, ctor) {
            if (name !== StringToLowerCase$1.call(name) || registry_1[name]) {
                throw new TypeError("Invalid Registration");
            }
            registry_1[name] = ctor;
            reverseRegistry_1.set(ctor, name);
        };
        getCustomElement = function get(name) {
            return registry_1[name];
        };
        HTMLElementConstructor = function HTMLElement() {
            if (!(this instanceof HTMLElement)) {
                throw new TypeError("Invalid Invocation");
            }
            var constructor = this.constructor;
            var name = reverseRegistry_1.get(constructor);
            if (!name) {
                throw new TypeError("Invalid Construction");
            }
            var elm = document.createElement(name);
            setPrototypeOf$2(elm, constructor.prototype);
            return elm;
        };
        HTMLElementConstructor.prototype = HTMLElement.prototype;
    } // TODO [#0]: Evaluate how we can extract the `$shadowToken$` property name in a shared package
    // to avoid having to synchronize it between the different modules.
    var useSyntheticShadow = hasOwnProperty$3.call(Element.prototype, '$shadowToken$');
    var renderer = {
        ssr: false,
        syntheticShadow: useSyntheticShadow,
        createElement: function (tagName, namespace) {
            return isUndefined$4(namespace) ? document.createElement(tagName) : document.createElementNS(namespace, tagName);
        },
        createText: function (content) {
            return document.createTextNode(content);
        },
        createComment: function (content) {
            return document.createComment(content);
        },
        insert: function (node, parent, anchor) {
            parent.insertBefore(node, anchor);
        },
        remove: function (node, parent) {
            parent.removeChild(node);
        },
        nextSibling: function (node) {
            return node.nextSibling;
        },
        attachShadow: function (element, options) {
            return element.attachShadow(options);
        },
        setText: function (node, content) {
            node.nodeValue = content;
        },
        getProperty: function (node, key) {
            return node[key];
        },
        setProperty: function (node, key, value) {
            node[key] = value;
        },
        getAttribute: function (element, name, namespace) {
            return isUndefined$4(namespace) ? element.getAttribute(name) : element.getAttributeNS(namespace, name);
        },
        setAttribute: function (element, name, value, namespace) {
            return isUndefined$4(namespace) ? element.setAttribute(name, value) : element.setAttributeNS(namespace, name, value);
        },
        removeAttribute: function (element, name, namespace) {
            if (isUndefined$4(namespace)) {
                element.removeAttribute(name);
            }
            else {
                element.removeAttributeNS(namespace, name);
            }
        },
        addEventListener: function (target, type, callback, options) {
            target.addEventListener(type, callback, options);
        },
        removeEventListener: function (target, type, callback, options) {
            target.removeEventListener(type, callback, options);
        },
        dispatchEvent: function (target, event) {
            return target.dispatchEvent(event);
        },
        getClassList: function (element) {
            return element.classList;
        },
        setCSSStyleProperty: function (element, name, value) {
            // TODO [#0]: How to avoid this type casting? Shall we use a different type interface to
            // represent elements in the engine?
            element.style.setProperty(name, value);
        },
        getBoundingClientRect: function (element) {
            return element.getBoundingClientRect();
        },
        querySelector: function (element, selectors) {
            return element.querySelector(selectors);
        },
        querySelectorAll: function (element, selectors) {
            return element.querySelectorAll(selectors);
        },
        getElementsByTagName: function (element, tagNameOrWildCard) {
            return element.getElementsByTagName(tagNameOrWildCard);
        },
        getElementsByClassName: function (element, names) {
            return element.getElementsByClassName(names);
        },
        isConnected: function (node) {
            return node.isConnected;
        },
        insertGlobalStylesheet: function (content) {
            if (!isUndefined$4(globalStylesheets[content])) {
                return;
            }
            globalStylesheets[content] = true;
            var elm = document.createElement('style');
            elm.type = 'text/css';
            elm.textContent = content;
            globalStylesheetsParentElement.appendChild(elm);
        },
        assertInstanceOfHTMLElement: function (elm, msg) {
            assert$1.invariant(elm instanceof HTMLElement, msg);
        },
        defineCustomElement: defineCustomElement,
        getCustomElement: getCustomElement,
        HTMLElement: HTMLElementConstructor
    };
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * This function builds a Web Component class from a LWC constructor so it can be
     * registered as a new element via customElements.define() at any given time.
     *
     * @deprecated since version 1.3.11
     *
     * @example
     * ```
     * import { buildCustomElementConstructor } from 'lwc';
     * import Foo from 'ns/foo';
     * const WC = buildCustomElementConstructor(Foo);
     * customElements.define('x-foo', WC);
     * const elm = document.createElement('x-foo');
     * ```
     */
    function deprecatedBuildCustomElementConstructor(Ctor) {
        return Ctor.CustomElementConstructor;
    }
    function buildCustomElementConstructor(Ctor) {
        var def = getComponentInternalDef(Ctor);
        return /** @class */ (function (_super) {
            __extends(class_1, _super);
            function class_1() {
                var _this = _super.call(this) || this;
                createVM(_this, def, {
                    mode: 'open',
                    owner: null,
                    tagName: _this.tagName,
                    renderer: renderer
                });
                return _this;
            }
            class_1.prototype.connectedCallback = function () {
                connectRootElement(this);
            };
            class_1.prototype.disconnectedCallback = function () {
                disconnectRootElement(this);
            };
            return class_1;
        }(def.bridge));
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ConnectingSlot = createHiddenField$1('connecting', 'engine');
    var DisconnectingSlot = createHiddenField$1('disconnecting', 'engine');
    function callNodeSlot(node, slot) {
        var fn = getHiddenField$1(node, slot);
        if (!isUndefined$4(fn)) {
            fn(node);
        }
        return node; // for convenience
    } // Monkey patching Node methods to be able to detect the insertions and removal of root elements
    // created via createElement.
    var _l = Node.prototype, appendChild = _l.appendChild, insertBefore = _l.insertBefore, removeChild = _l.removeChild, replaceChild = _l.replaceChild;
    assign$2(Node.prototype, {
        appendChild: function (newChild) {
            var appendedNode = appendChild.call(this, newChild);
            return callNodeSlot(appendedNode, ConnectingSlot);
        },
        insertBefore: function (newChild, referenceNode) {
            var insertedNode = insertBefore.call(this, newChild, referenceNode);
            return callNodeSlot(insertedNode, ConnectingSlot);
        },
        removeChild: function (oldChild) {
            var removedNode = removeChild.call(this, oldChild);
            return callNodeSlot(removedNode, DisconnectingSlot);
        },
        replaceChild: function (newChild, oldChild) {
            var replacedNode = replaceChild.call(this, newChild, oldChild);
            callNodeSlot(replacedNode, DisconnectingSlot);
            callNodeSlot(newChild, ConnectingSlot);
            return replacedNode;
        }
    });
    /**
     * EXPERIMENTAL: This function is almost identical to document.createElement with the slightly
     * difference that in the options, you can pass the `is` property set to a Constructor instead of
     * just a string value. The intent is to allow the creation of an element controlled by LWC without
     * having to register the element as a custom element.
     *
     * @example
     * ```
     * const el = createElement('x-foo', { is: FooCtor });
     * ```
     */
    function createElement(sel, options) {
        if (!isObject$1(options) || isNull$1(options)) {
            throw new TypeError("\"createElement\" function expects an object as second parameter but received \"" + toString$2(options) + "\".");
        }
        var Ctor = options.is;
        if (!isFunction$2(Ctor)) {
            throw new TypeError("\"createElement\" function expects an \"is\" option with a valid component constructor.");
        }
        var UpgradableConstructor = getUpgradableConstructor(sel, renderer);
        var wasComponentUpgraded = false; // the custom element from the registry is expecting an upgrade callback
        /**
         * Note: if the upgradable constructor does not expect, or throw when we new it
         * with a callback as the first argument, we could implement a more advanced
         * mechanism that only passes that argument if the constructor is known to be
         * an upgradable custom element.
         */
        var element = new UpgradableConstructor(function (elm) {
            var def = getComponentInternalDef(Ctor);
            createVM(elm, def, {
                tagName: sel,
                mode: options.mode !== 'closed' ? 'open' : 'closed',
                owner: null,
                renderer: renderer
            });
            setHiddenField$1(elm, ConnectingSlot, connectRootElement);
            setHiddenField$1(elm, DisconnectingSlot, disconnectRootElement);
            wasComponentUpgraded = true;
        });
        if (!wasComponentUpgraded) {
            /* eslint-disable-next-line no-console */
            console.error("Unexpected tag name \"" + sel + "\". This name is a registered custom element, preventing LWC to upgrade the element.");
        }
        return element;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function provides access to the component constructor, given an HTMLElement.
     * This API is subject to change or being removed.
     */
    function getComponentConstructor(elm) {
        var ctor = null;
        if (elm instanceof HTMLElement) {
            var vm = getAssociatedVMIfPresent(elm);
            if (!isUndefined$4(vm)) {
                ctor = vm.def.ctor;
            }
        }
        return ctor;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    /**
     * EXPERIMENTAL: This function detects whether or not a Node is controlled by a LWC template. This
     * API is subject to change or being removed.
     */
    function isNodeFromTemplate(node) {
        if (isFalse$3(node instanceof Node)) {
            return false;
        } // TODO [#1250]: skipping the shadowRoot instances itself makes no sense, we need to revisit
        // this with locker
        if (node instanceof ShadowRoot) {
            return false;
        }
        if (useSyntheticShadow) {
            // TODO [#1252]: old behavior that is still used by some pieces of the platform,
            // specifically, nodes inserted manually on places where `lwc:dom="manual"` directive is not
            // used, will be considered global elements.
            if (isUndefined$4(node.$shadowResolver$)) {
                return false;
            }
        }
        var root = node.getRootNode();
        return root instanceof ShadowRoot;
    }
    /*
     * Copyright (c) 2018, salesforce.com, inc.
     * All rights reserved.
     * SPDX-License-Identifier: MIT
     * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
     */
    var ComponentConstructorToCustomElementConstructorMap = new Map();
    function getCustomElementConstructor(Ctor) {
        if (Ctor === LightningElement) {
            throw new TypeError("Invalid Constructor. LightningElement base class can't be claimed as a custom element.");
        }
        var ce = ComponentConstructorToCustomElementConstructorMap.get(Ctor);
        if (isUndefined$4(ce)) {
            ce = buildCustomElementConstructor(Ctor);
            ComponentConstructorToCustomElementConstructorMap.set(Ctor, ce);
        }
        return ce;
    }
    /**
     * This static getter builds a Web Component class from a LWC constructor so it can be registered
     * as a new element via customElements.define() at any given time. E.g.:
     *
     *      import Foo from 'ns/foo';
     *      customElements.define('x-foo', Foo.CustomElementConstructor);
     *      const elm = document.createElement('x-foo');
     *
     */
    defineProperty$2(LightningElement, 'CustomElementConstructor', {
        get: function () {
            return getCustomElementConstructor(this);
        }
    });
    freeze$2(LightningElement);
    seal$2(LightningElement.prototype);
    /* version: 2.1.2 */

    exports.LightningElement = LightningElement;
    exports.__unstable__ProfilerControl = profilerControl;
    exports.api = api$1;
    exports.buildCustomElementConstructor = deprecatedBuildCustomElementConstructor;
    exports.createContextProvider = createContextProvider;
    exports.createElement = createElement;
    exports.getComponentConstructor = getComponentConstructor;
    exports.getComponentDef = getComponentDef;
    exports.isComponentConstructor = isComponentConstructor;
    exports.isNodeFromTemplate = isNodeFromTemplate;
    exports.readonly = readonly;
    exports.register = register;
    exports.registerComponent = registerComponent;
    exports.registerDecorators = registerDecorators;
    exports.registerTemplate = registerTemplate;
    exports.sanitizeAttribute = sanitizeAttribute;
    exports.setFeatureFlag = setFeatureFlag;
    exports.setFeatureFlagForTest = setFeatureFlagForTest;
    exports.swapComponent = swapComponent;
    exports.swapStyle = swapStyle;
    exports.swapTemplate = swapTemplate;
    exports.track = track;
    exports.unwrap = unwrap;
    exports.wire = wire;

    Object.defineProperty(exports, '__esModule', { value: true });

})));
