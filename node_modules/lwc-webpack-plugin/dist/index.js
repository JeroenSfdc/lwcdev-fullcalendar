"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
exports.__esModule = true;
/* eslint-disable no-prototype-builtins */
var path_1 = require("path");
var module_resolver_1 = require("./module-resolver");
var fs_1 = require("fs");
var resolve_1 = __importDefault(require("resolve"));
var PACKAGE_JSON = 'package.json';
function transformModuleRecordsToIncludes(modulesConfig) {
    var modules = [];
    var pkgJson = JSON.parse(fs_1.readFileSync(path_1.resolve(process.cwd(), 'package.json'), 'utf8'));
    if (pkgJson.lwc && pkgJson.lwc.modules && pkgJson.lwc.modules.length) {
        modules = pkgJson.lwc.modules;
    }
    if (fs_1.existsSync(path_1.resolve(process.cwd(), 'lwc.config.json'))) {
        var lwcConfig = JSON.parse(fs_1.readFileSync(path_1.resolve(process.cwd(), 'lwc.config.json'), 'utf8'));
        if (lwcConfig.modules && lwcConfig.modules.length) {
            modules = lwcConfig.modules;
        }
    }
    if (modulesConfig && modulesConfig.length) {
        modules = modulesConfig;
    }
    var records = [];
    for (var _i = 0, modules_1 = modules; _i < modules_1.length; _i++) {
        var module_1 = modules_1[_i];
        if (module_1.hasOwnProperty('npm')) {
            try {
                var resolved = resolve_1["default"].sync(module_1.npm, {
                    /* Use packageFilter in order to be able to 'resolve' packages
                     * that may incorrectly not-specify the 'main' property, which is
                     * required for a node module to be correctly detected.
                     */
                    packageFilter: function (pkg) {
                        pkg.main = PACKAGE_JSON;
                        return pkg;
                    },
                    basedir: process.cwd()
                });
                resolved = resolved.slice(0, -PACKAGE_JSON.length);
                records.push(resolved);
            }
            catch (ignore) {
                // log errors
                console.log(ignore);
            }
        }
        else if (module_1.hasOwnProperty('dir')) {
            records.push(path_1.resolve(process.cwd(), module_1.dir));
        }
        else if (module_1.hasOwnProperty('alias')) {
            records.push(path_1.resolve(process.cwd(), module_1.path));
        }
    }
    return records;
}
var EXTENSIONS = ['.js', '.ts'];
module.exports = /** @class */ (function () {
    function Plugin(config) {
        this.config = config;
    }
    Plugin.prototype.apply = function (compiler) {
        var _a;
        var _b = this.config || {}, _c = _b.modules, modules = _c === void 0 ? [] : _c, _d = _b.stylesheetConfig, stylesheetConfig = _d === void 0 ? {} : _d, _e = _b.outputConfig, outputConfig = _e === void 0 ? {} : _e, _f = _b.experimentalDynamicComponent, experimentalDynamicComponent = _f === void 0 ? {} : _f;
        compiler.hooks.environment.tap('lwc-webpack-plugin', function () {
            var resolverPlugin = new module_resolver_1.LwcModuleResolverPlugin(modules);
            compiler.options.resolve.plugins = [resolverPlugin];
            compiler.options.resolveLoader.plugins = [resolverPlugin];
            var rules = compiler.options.module.rules;
            if (rules === undefined) {
                rules = compiler.options.module.rules = [];
            }
        });
        var alias = compiler.options.resolve.alias;
        if (alias === undefined) {
            alias = compiler.options.resolve.alias = {};
        }
        // Specify known package aliases
        alias['lwc'] = require.resolve('@lwc/engine-dom');
        alias['wire-service'] = require.resolve('@lwc/wire-service');
        // the 'main' property for @lwc/synthetic-shadow refers to a file that
        // simply logs an error message. This needs to be fixed up to directly
        // specify the actual implementation, which lives under
        // /dist/synthetic-shadow.js. Note: this depends on the internal file
        // structure of this component, and there is a little fragile, if the
        // module ever changes where this implementation lives.
        alias['@lwc/synthetic-shadow'] = require.resolve('@lwc/synthetic-shadow/dist/synthetic-shadow.js');
        if (compiler.options.resolve.extensions) {
            (_a = compiler.options.resolve.extensions).push.apply(_a, EXTENSIONS);
        }
        else {
            compiler.options.resolve.extensions = EXTENSIONS;
        }
        compiler.options.module.rules.push({
            test: /\.(js|ts|html|css)$/,
            include: transformModuleRecordsToIncludes(modules),
            use: {
                loader: require.resolve('./loader'),
                options: {
                    stylesheetConfig: stylesheetConfig,
                    outputConfig: outputConfig,
                    experimentalDynamicComponent: experimentalDynamicComponent
                }
            }
        });
    };
    return Plugin;
}());
