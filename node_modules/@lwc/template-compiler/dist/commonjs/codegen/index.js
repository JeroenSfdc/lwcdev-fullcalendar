"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
/*
 * Copyright (c) 2018, salesforce.com, inc.
 * All rights reserved.
 * SPDX-License-Identifier: MIT
 * For full license text, see the LICENSE file in the repo root or https://opensource.org/licenses/MIT
 */
const astring = __importStar(require("astring"));
const shared_1 = require("@lwc/shared");
const errors_1 = require("@lwc/errors");
const ir_1 = require("../shared/ir");
const constants_1 = require("../shared/constants");
const types_1 = require("../shared/types");
const codegen_1 = __importDefault(require("./codegen"));
const scope_1 = require("./scope");
const helpers_1 = require("./helpers");
const module_1 = require("./formatters/module");
const function_1 = require("./formatters/function");
const t = __importStar(require("../shared/estree"));
const attribute_1 = require("../parser/attribute");
function transform(root, codeGen, state) {
    function transformElement(element) {
        const databag = elementDataBag(element);
        let res;
        const children = transformChildren(element.children);
        // Check wether it has the special directive lwc:dynamic
        if (element.lwc && element.lwc.dynamic) {
            const expression = scope_1.bindExpression(element.lwc.dynamic, element);
            res = codeGen.genDynamicElement(element.tag, expression, databag, children);
        }
        else if (ir_1.isCustomElement(element)) {
            // Make sure to register the component
            const componentClassName = element.component;
            res = codeGen.genCustomElement(element.tag, helpers_1.identifierFromComponentName(componentClassName), databag, children);
        }
        else if (ir_1.isSlot(element)) {
            const defaultSlot = children;
            res = codeGen.getSlot(element.slotName, databag, defaultSlot);
        }
        else {
            res = codeGen.genElement(element.tag, databag, children);
        }
        res = applyInlineIf(element, res);
        res = applyInlineFor(element, res);
        return res;
    }
    function transformTemplate(element) {
        const children = transformChildren(element.children);
        let res = applyTemplateIf(element, children);
        if (element.forEach) {
            res = applyTemplateFor(element, res);
        }
        else if (element.forOf) {
            res = applyTemplateForOf(element, res);
        }
        if (t.isArrayExpression(res) && element.if) {
            return res.elements;
        }
        else {
            return res;
        }
    }
    function transformText(text) {
        const { value } = text;
        return codeGen.genText(typeof value === 'string' ? value : scope_1.bindExpression(value, text));
    }
    function transformComment(comment) {
        return codeGen.genComment(comment.value);
    }
    function transformChildren(children) {
        const res = children.reduce((acc, child) => {
            let expr;
            if (ir_1.isElement(child)) {
                expr = ir_1.isTemplate(child) ? transformTemplate(child) : transformElement(child);
            }
            else if (ir_1.isTextNode(child)) {
                expr = transformText(child);
            }
            else if (ir_1.isCommentNode(child)) {
                expr = transformComment(child);
            }
            return acc.concat(expr);
        }, []);
        if (helpers_1.shouldFlatten(children, state)) {
            if (children.length === 1 && !helpers_1.containsDynamicChildren(children)) {
                return res[0];
            }
            else {
                return codeGen.genFlatten([t.arrayExpression(res)]);
            }
        }
        else {
            return t.arrayExpression(res);
        }
    }
    function applyInlineIf(element, node, testExpression, falseValue) {
        if (!element.if) {
            return node;
        }
        if (!testExpression) {
            testExpression = scope_1.bindExpression(element.if, element);
        }
        let leftExpression;
        const modifier = element.ifModifier;
        if (modifier === 'true') {
            leftExpression = testExpression;
        }
        else if (modifier === 'false') {
            leftExpression = t.unaryExpression('!', testExpression);
        }
        else if (modifier === 'strict-true') {
            leftExpression = t.binaryExpression('===', testExpression, t.literal(true));
        }
        else {
            throw errors_1.generateCompilerError(errors_1.TemplateErrors.UNKNOWN_IF_MODIFIER, {
                messageArgs: [modifier],
            });
        }
        return t.conditionalExpression(leftExpression, node, falseValue !== null && falseValue !== void 0 ? falseValue : t.literal(null));
    }
    function applyInlineFor(element, node) {
        if (!element.forEach) {
            return node;
        }
        const { expression, item, index } = element.forEach;
        const params = [item];
        if (index) {
            params.push(index);
        }
        const iterable = scope_1.bindExpression(expression, element);
        const iterationFunction = t.functionExpression(null, params, t.blockStatement([t.returnStatement(node)]));
        return codeGen.genIterator(iterable, iterationFunction);
    }
    function applyInlineForOf(element, node) {
        if (!element.forOf) {
            return node;
        }
        const { expression, iterator } = element.forOf;
        const { name: iteratorName } = iterator;
        const argsMapping = {
            value: `${iteratorName}Value`,
            index: `${iteratorName}Index`,
            first: `${iteratorName}First`,
            last: `${iteratorName}Last`,
        };
        const iteratorArgs = Object.values(argsMapping).map((arg) => t.identifier(arg));
        const iteratorObjet = t.objectExpression(Object.entries(argsMapping).map(([prop, arg]) => t.property(t.identifier(prop), t.identifier(arg))));
        const iterable = scope_1.bindExpression(expression, element);
        const iterationFunction = t.functionExpression(null, iteratorArgs, t.blockStatement([
            t.variableDeclaration('const', [
                t.variableDeclarator(t.identifier(iteratorName), iteratorObjet),
            ]),
            t.returnStatement(node),
        ]));
        return codeGen.genIterator(iterable, iterationFunction);
    }
    function applyTemplateForOf(element, fragmentNodes) {
        let expression = fragmentNodes;
        if (t.isArrayExpression(expression) && expression.elements.length === 1) {
            expression = expression.elements[0];
        }
        return applyInlineForOf(element, expression);
    }
    function applyTemplateFor(element, fragmentNodes) {
        let expression = fragmentNodes;
        if (t.isArrayExpression(expression) && expression.elements.length === 1) {
            expression = expression.elements[0];
        }
        return applyInlineFor(element, expression);
    }
    function applyTemplateIf(element, fragmentNodes) {
        if (!element.if) {
            return fragmentNodes;
        }
        if (t.isArrayExpression(fragmentNodes)) {
            // Bind the expression once for all the template children
            const testExpression = scope_1.bindExpression(element.if, element);
            return t.arrayExpression(fragmentNodes.elements.map((child) => child !== null
                ? applyInlineIf(element, child, testExpression)
                : null));
        }
        else {
            // If the template has a single children, make sure the ternary expression returns an array
            return applyInlineIf(element, fragmentNodes, undefined, t.arrayExpression([]));
        }
    }
    function computeAttrValue(attr, element) {
        const { namespaceURI, tagName } = element.__original;
        const isUsedAsAttribute = attribute_1.isAttribute(element, attr.name);
        switch (attr.type) {
            case types_1.IRAttributeType.Expression: {
                const expression = scope_1.bindExpression(attr.value, element);
                // TODO [#2012]: Normalize global boolean attrs values passed to custom elements as props
                if (isUsedAsAttribute && shared_1.isBooleanAttribute(attr.name, tagName)) {
                    // We need to do some manipulation to allow the diffing algorithm add/remove the attribute
                    // without handling special cases at runtime.
                    return codeGen.genBooleanAttributeExpr(expression);
                }
                if (attr.name === 'tabindex') {
                    return codeGen.genTabIndex([expression]);
                }
                if (attr.name === 'id' || attribute_1.isIdReferencingAttribute(attr.name)) {
                    return codeGen.genScopedId(expression);
                }
                if (state.shouldScopeFragmentId &&
                    attribute_1.isAllowedFragOnlyUrlsXHTML(tagName, attr.name, namespaceURI)) {
                    return codeGen.genScopedFragId(expression);
                }
                if (attribute_1.isSvgUseHref(tagName, attr.name, namespaceURI)) {
                    return t.callExpression(t.identifier('sanitizeAttribute'), [
                        t.literal(tagName),
                        t.literal(namespaceURI),
                        t.literal(attr.name),
                        codeGen.genScopedFragId(expression),
                    ]);
                }
                return expression;
            }
            case types_1.IRAttributeType.String: {
                if (attr.name === 'id') {
                    return codeGen.genScopedId(attr.value);
                }
                if (attr.name === 'spellcheck') {
                    return t.literal(attr.value.toLowerCase() !== 'false');
                }
                if (!isUsedAsAttribute && shared_1.isBooleanAttribute(attr.name, tagName)) {
                    // We are in presence of a string value, for a recognized boolean attribute, which is used as
                    // property. for these cases, always set the property to true.
                    return t.literal(true);
                }
                if (attribute_1.isIdReferencingAttribute(attr.name)) {
                    return codeGen.genScopedId(attr.value);
                }
                if (state.shouldScopeFragmentId &&
                    attribute_1.isAllowedFragOnlyUrlsXHTML(tagName, attr.name, namespaceURI) &&
                    attribute_1.isFragmentOnlyUrl(attr.value)) {
                    return codeGen.genScopedFragId(attr.value);
                }
                if (attribute_1.isSvgUseHref(tagName, attr.name, namespaceURI)) {
                    return t.callExpression(t.identifier('sanitizeAttribute'), [
                        t.literal(tagName),
                        t.literal(namespaceURI),
                        t.literal(attr.name),
                        attribute_1.isFragmentOnlyUrl(attr.value)
                            ? codeGen.genScopedFragId(attr.value)
                            : t.literal(attr.value),
                    ]);
                }
                return t.literal(attr.value);
            }
            case types_1.IRAttributeType.Boolean: {
                // A boolean value used in an attribute should always generate .setAttribute(attr.name, ''),
                // regardless if is a boolean attribute or not.
                return isUsedAsAttribute ? t.literal('') : t.literal(attr.value);
            }
        }
    }
    function elementDataBag(element) {
        const data = [];
        const { classMap, className, style, styleMap, attrs, props, on, forKey, lwc } = element;
        // Class attibute defined via string
        if (className) {
            const classExpression = scope_1.bindExpression(className, element);
            data.push(t.property(t.identifier('className'), classExpression));
        }
        // Class attribute defined via object
        if (classMap) {
            const classMapObj = helpers_1.objectToAST(classMap, () => t.literal(true));
            data.push(t.property(t.identifier('classMap'), classMapObj));
        }
        // Style attribute defined via object
        if (styleMap) {
            const styleObj = helpers_1.objectToAST(styleMap, (key) => t.literal(styleMap[key]));
            data.push(t.property(t.identifier('styleMap'), styleObj));
        }
        // Style attribute defined via string
        if (style) {
            const styleExpression = scope_1.bindExpression(style, element);
            data.push(t.property(t.identifier('style'), styleExpression));
        }
        // Attributes
        if (attrs) {
            const attrsObj = helpers_1.objectToAST(attrs, (key) => computeAttrValue(attrs[key], element));
            data.push(t.property(t.identifier('attrs'), attrsObj));
        }
        // Properties
        if (props) {
            const propsObj = helpers_1.objectToAST(props, (key) => computeAttrValue(props[key], element));
            data.push(t.property(t.identifier('props'), propsObj));
        }
        // Context
        if (lwc === null || lwc === void 0 ? void 0 : lwc.dom) {
            const contextObj = t.objectExpression([
                t.property(t.identifier('lwc'), t.objectExpression([t.property(t.identifier('dom'), t.literal(lwc.dom))])),
            ]);
            data.push(t.property(t.identifier('context'), contextObj));
        }
        // Key property on VNode
        if (forKey) {
            // If element has user-supplied `key` or is in iterator, call `api.k`
            const forKeyExpression = scope_1.bindExpression(forKey, element);
            const generatedKey = codeGen.genKey(t.literal(codeGen.generateKey()), forKeyExpression);
            data.push(t.property(t.identifier('key'), generatedKey));
        }
        else {
            // If stand alone element with no user-defined key
            // member expression id
            data.push(t.property(t.identifier('key'), t.literal(codeGen.generateKey())));
        }
        // Event handler
        if (on) {
            const onObj = helpers_1.objectToAST(on, (key) => {
                const componentHandler = scope_1.bindExpression(on[key], element);
                const handler = codeGen.genBind(componentHandler);
                return helpers_1.memorizeHandler(codeGen, element, componentHandler, handler);
            });
            data.push(t.property(t.identifier('on'), onObj));
        }
        return t.objectExpression(data);
    }
    return transformChildren(root.children);
}
function generateTemplateFunction(templateRoot, state) {
    const codeGen = new codegen_1.default();
    const returnedValue = transform(templateRoot, codeGen, state);
    const args = [
        constants_1.TEMPLATE_PARAMS.API,
        constants_1.TEMPLATE_PARAMS.INSTANCE,
        constants_1.TEMPLATE_PARAMS.SLOT_SET,
        constants_1.TEMPLATE_PARAMS.CONTEXT,
    ].map((id) => t.identifier(id));
    const body = [
        t.variableDeclaration('const', [
            t.variableDeclarator(t.objectPattern(Object.keys(codeGen.usedApis).map((name) => t.assignmentProperty(t.identifier(name), codeGen.usedApis[name]))), t.identifier(constants_1.TEMPLATE_PARAMS.API)),
        ]),
    ];
    if (Object.keys(codeGen.usedSlots).length) {
        body.push(t.variableDeclaration('const', [
            t.variableDeclarator(t.objectPattern(Object.keys(codeGen.usedApis).map((name) => t.assignmentProperty(t.literal(name), codeGen.usedSlots[name], {
                computed: true,
            }))), t.identifier(constants_1.TEMPLATE_PARAMS.SLOT_SET)),
        ]));
    }
    if (codeGen.memorizedIds.length) {
        body.push(t.variableDeclaration('const', [
            t.variableDeclarator(t.objectPattern(codeGen.memorizedIds.map((id) => t.assignmentProperty(id, id, { shorthand: true }))), t.identifier(constants_1.TEMPLATE_PARAMS.CONTEXT)),
        ]));
    }
    body.push(t.returnStatement(returnedValue));
    return t.functionDeclaration(t.identifier(constants_1.TEMPLATE_FUNCTION_NAME), args, t.blockStatement(body));
}
function format({ config }) {
    switch (config.format) {
        case 'function':
            return function_1.format;
        default:
            return module_1.format;
    }
}
function default_1(templateRoot, state) {
    const templateFunction = generateTemplateFunction(templateRoot, state);
    const formatter = format(state);
    const program = formatter(templateFunction, state);
    return astring.generate(program);
}
exports.default = default_1;
//# sourceMappingURL=index.js.map